# Story 10.5.8: Risk-Based Position Sizing

## Story Info
- **Epic**: Epic 10.5 - Order Management, Price Oracle & Risk-Based Sizing
- **Status**: done
- **Priority**: P0 - Critical
- **Story Points**: 5
- **Depends on**: None (peut démarrer en parallèle)

## User Story

**As an** operator,
**I want** que la taille de position soit basée sur le risque réel,
**So that** je ne risque jamais plus de X% de mon capital par trade.

## Acceptance Criteria

### AC 1: Risk-Based Calculation
**Given** risk_per_trade_pct = 1% et capital = 1000 SOL
**When** je calcule la taille pour un trade avec SL = 10%
**Then** position_size = (1000 * 0.01) / 0.10 = 100 SOL
**And** le risque max = 100 * 0.10 = 10 SOL = 1% du capital

### AC 2: Stop Loss Impact
**Given** le même capital (1000 SOL) et risk (1%)
**When** le SL est plus serré (5%)
**Then** position_size = (1000 * 0.01) / 0.05 = 200 SOL (plus grosse position)
**When** le SL est plus large (20%)
**Then** position_size = (1000 * 0.01) / 0.20 = 50 SOL (plus petite position)

### AC 3: Min/Max Bounds
**Given** la position calculée est de 500 SOL
**When** max_position_sol = 100 SOL (config)
**Then** position_size est cappée à 100 SOL
**And** la raison est loggée ("size capped to max")

### AC 4: Conviction Multiplier
**Given** un signal avec score = 0.90 (high conviction)
**When** high_conviction_threshold = 0.85
**Then** le multiplier 1.5x est appliqué
**And** position_size_final = calculated * 1.5

### AC 5: Sizing Mode Switch
**Given** sizing_mode peut être 'risk_based' ou 'fixed_percent'
**When** sizing_mode = 'fixed_percent'
**Then** l'ancienne logique est utilisée (base_position_pct * capital)
**And** le SL n'affecte pas la taille

### AC 6: Database Config Integration
**Given** risk_config dans Supabase contient risk_per_trade_pct
**When** le config est modifié via UI
**Then** le nouveau sizing s'applique immédiatement
**And** pas de redémarrage nécessaire (hot-reload)

## Technical Specifications

### Enhanced Position Sizer

**src/walltrack/services/trade/position_sizer.py (refactor):**
```python
"""Enhanced position sizer with risk-based sizing."""

from dataclasses import dataclass
from decimal import Decimal
from enum import Enum
from typing import Optional

import structlog

from walltrack.models.signal import Signal
from walltrack.services.config.config_service import ConfigService, get_config_service

logger = structlog.get_logger(__name__)


class SizingMode(str, Enum):
    """Position sizing mode."""
    RISK_BASED = "risk_based"
    FIXED_PERCENT = "fixed_percent"


@dataclass
class SizingResult:
    """Result of position size calculation."""
    amount_sol: Decimal
    mode: SizingMode
    risk_amount_sol: Decimal  # Max SOL at risk
    raw_calculated: Decimal  # Before caps
    was_capped: bool
    cap_reason: Optional[str] = None
    multiplier_applied: Decimal = Decimal("1.0")


@dataclass
class SizingConfig:
    """Configuration for position sizing."""
    # Mode
    sizing_mode: SizingMode = SizingMode.RISK_BASED

    # Risk-based parameters
    risk_per_trade_pct: Decimal = Decimal("1.0")  # 1% risk per trade

    # Fixed-percent parameters (fallback)
    base_position_pct: Decimal = Decimal("2.0")  # 2% of capital

    # Bounds
    min_position_sol: Decimal = Decimal("0.01")
    max_position_sol: Decimal = Decimal("10.0")

    # Conviction multipliers
    high_conviction_threshold: Decimal = Decimal("0.85")
    high_conviction_multiplier: Decimal = Decimal("1.5")


class PositionSizer:
    """
    Calculates position sizes based on risk management.

    Supports two modes:
    - risk_based: Size based on max risk per trade and stop loss
    - fixed_percent: Fixed percentage of capital (legacy)
    """

    def __init__(self, config_service: ConfigService):
        self.config_service = config_service
        self._cached_config: Optional[SizingConfig] = None

    async def _get_config(self) -> SizingConfig:
        """Get sizing config from database."""
        trading_config = await self.config_service.get_trading_config()
        risk_config = await self.config_service.get_risk_config()

        return SizingConfig(
            sizing_mode=SizingMode(risk_config.sizing_mode),
            risk_per_trade_pct=risk_config.risk_per_trade_pct,
            base_position_pct=trading_config.base_position_size_pct,
            min_position_sol=trading_config.min_position_sol,
            max_position_sol=trading_config.max_position_sol,
            high_conviction_threshold=trading_config.high_conviction_threshold,
            high_conviction_multiplier=trading_config.high_conviction_multiplier,
        )

    async def calculate(
        self,
        signal: Signal,
        capital: Decimal,
        stop_loss_pct: Decimal,
    ) -> SizingResult:
        """
        Calculate position size for a signal.

        Args:
            signal: The trading signal
            capital: Available trading capital in SOL
            stop_loss_pct: Stop loss percentage (e.g., 10 for 10%)

        Returns:
            SizingResult with calculated size and metadata
        """
        config = await self._get_config()

        log = logger.bind(
            signal_id=signal.id,
            capital=str(capital),
            stop_loss_pct=str(stop_loss_pct),
            mode=config.sizing_mode.value
        )

        if config.sizing_mode == SizingMode.RISK_BASED:
            result = self._calculate_risk_based(
                config=config,
                capital=capital,
                stop_loss_pct=stop_loss_pct,
                signal_score=signal.score,
            )
        else:
            result = self._calculate_fixed_percent(
                config=config,
                capital=capital,
                signal_score=signal.score,
            )

        log.info(
            "position_size_calculated",
            amount_sol=str(result.amount_sol),
            risk_amount=str(result.risk_amount_sol),
            was_capped=result.was_capped,
            multiplier=str(result.multiplier_applied)
        )

        return result

    def _calculate_risk_based(
        self,
        config: SizingConfig,
        capital: Decimal,
        stop_loss_pct: Decimal,
        signal_score: Decimal,
    ) -> SizingResult:
        """
        Calculate using risk-based sizing.

        Formula: position_size = max_risk / stop_loss_pct
        Where: max_risk = capital * risk_per_trade_pct / 100
        """
        # Calculate max risk in SOL
        max_risk_sol = capital * config.risk_per_trade_pct / Decimal("100")

        # Calculate position size
        # If SL = 10%, and max risk = 10 SOL, position = 100 SOL
        if stop_loss_pct <= 0:
            stop_loss_pct = Decimal("10")  # Default 10% if not specified

        raw_position = max_risk_sol / (stop_loss_pct / Decimal("100"))

        # Apply conviction multiplier
        multiplier = Decimal("1.0")
        if signal_score >= config.high_conviction_threshold:
            multiplier = config.high_conviction_multiplier
            raw_position *= multiplier

        # Apply bounds
        final_position = raw_position
        was_capped = False
        cap_reason = None

        if raw_position < config.min_position_sol:
            final_position = config.min_position_sol
            was_capped = True
            cap_reason = f"Below minimum ({config.min_position_sol} SOL)"

        if raw_position > config.max_position_sol:
            final_position = config.max_position_sol
            was_capped = True
            cap_reason = f"Above maximum ({config.max_position_sol} SOL)"

        # Calculate actual risk with final position
        actual_risk = final_position * (stop_loss_pct / Decimal("100"))

        return SizingResult(
            amount_sol=final_position,
            mode=SizingMode.RISK_BASED,
            risk_amount_sol=actual_risk,
            raw_calculated=raw_position,
            was_capped=was_capped,
            cap_reason=cap_reason,
            multiplier_applied=multiplier,
        )

    def _calculate_fixed_percent(
        self,
        config: SizingConfig,
        capital: Decimal,
        signal_score: Decimal,
    ) -> SizingResult:
        """
        Calculate using fixed percentage (legacy mode).

        Formula: position_size = capital * base_position_pct / 100
        """
        raw_position = capital * config.base_position_pct / Decimal("100")

        # Apply conviction multiplier
        multiplier = Decimal("1.0")
        if signal_score >= config.high_conviction_threshold:
            multiplier = config.high_conviction_multiplier
            raw_position *= multiplier

        # Apply bounds
        final_position = raw_position
        was_capped = False
        cap_reason = None

        if raw_position < config.min_position_sol:
            final_position = config.min_position_sol
            was_capped = True
            cap_reason = f"Below minimum"

        if raw_position > config.max_position_sol:
            final_position = config.max_position_sol
            was_capped = True
            cap_reason = f"Above maximum"

        return SizingResult(
            amount_sol=final_position,
            mode=SizingMode.FIXED_PERCENT,
            risk_amount_sol=final_position,  # In fixed mode, entire position is "at risk"
            raw_calculated=raw_position,
            was_capped=was_capped,
            cap_reason=cap_reason,
            multiplier_applied=multiplier,
        )


# Singleton
_sizer: Optional[PositionSizer] = None


async def get_position_sizer() -> PositionSizer:
    """Get or create position sizer."""
    global _sizer

    if _sizer is None:
        _sizer = PositionSizer(await get_config_service())

    return _sizer
```

### Gradio Config UI

**src/walltrack/ui/pages/config/sizing_config.py:**
```python
"""Position sizing configuration UI."""

import gradio as gr
from decimal import Decimal


def create_sizing_config_panel():
    """Create sizing configuration panel."""

    with gr.Column() as sizing_panel:
        gr.Markdown("## Position Sizing")

        sizing_mode = gr.Radio(
            choices=["risk_based", "fixed_percent"],
            value="risk_based",
            label="Sizing Mode",
            info="Risk-based adjusts position size based on stop loss distance"
        )

        with gr.Group(visible=True) as risk_based_group:
            gr.Markdown("### Risk-Based Settings")

            risk_per_trade = gr.Slider(
                minimum=0.1,
                maximum=5.0,
                value=1.0,
                step=0.1,
                label="Risk Per Trade (%)",
                info="Maximum capital at risk per trade"
            )

            gr.Markdown("""
            **Example with 1000 SOL capital:**
            - Risk 1% = 10 SOL max loss per trade
            - With 10% SL → Position = 100 SOL
            - With 5% SL → Position = 200 SOL
            - With 20% SL → Position = 50 SOL
            """)

        with gr.Group(visible=False) as fixed_group:
            gr.Markdown("### Fixed Percentage Settings")

            base_position_pct = gr.Slider(
                minimum=0.5,
                maximum=10.0,
                value=2.0,
                step=0.5,
                label="Base Position (%)",
                info="Fixed percentage of capital per trade"
            )

        gr.Markdown("### Position Bounds")

        with gr.Row():
            min_position = gr.Number(
                value=0.01,
                label="Min Position (SOL)",
                precision=4
            )
            max_position = gr.Number(
                value=10.0,
                label="Max Position (SOL)",
                precision=4
            )

        gr.Markdown("### Conviction Multiplier")

        with gr.Row():
            conviction_threshold = gr.Slider(
                minimum=0.70,
                maximum=0.95,
                value=0.85,
                step=0.05,
                label="High Conviction Threshold"
            )
            conviction_multiplier = gr.Slider(
                minimum=1.0,
                maximum=3.0,
                value=1.5,
                step=0.1,
                label="Multiplier"
            )

        save_btn = gr.Button("Save Sizing Config", variant="primary")
        status = gr.Textbox(label="Status", interactive=False)

    # Toggle visibility based on mode
    def toggle_mode(mode):
        return (
            gr.update(visible=mode == "risk_based"),
            gr.update(visible=mode == "fixed_percent")
        )

    sizing_mode.change(
        toggle_mode,
        inputs=[sizing_mode],
        outputs=[risk_based_group, fixed_group]
    )

    return sizing_panel, {
        "sizing_mode": sizing_mode,
        "risk_per_trade": risk_per_trade,
        "base_position_pct": base_position_pct,
        "min_position": min_position,
        "max_position": max_position,
        "conviction_threshold": conviction_threshold,
        "conviction_multiplier": conviction_multiplier,
        "save_btn": save_btn,
        "status": status,
    }
```

## Implementation Tasks

- [x] Refactor PositionSizer with SizingMode
- [x] Implement risk-based calculation formula
- [x] Implement fixed-percent (legacy) mode
- [x] Add conviction multiplier support
- [x] Add min/max bounds with logging
- [x] Integrate with ConfigService for hot-reload
- [ ] Create Gradio sizing config panel (deferred to Story 10.5-13)
- [ ] Add sizing calculator preview (deferred to Story 10.5-13)
- [x] Write unit tests for both modes
- [x] Write integration tests with config changes

## Definition of Done

- [x] Risk-based sizing calculates correctly
- [x] SL distance affects position size inversely
- [x] Conviction multiplier applied correctly
- [x] Min/max bounds respected
- [x] Mode switchable via config
- [x] Config changes apply without restart
- [x] Full test coverage

## Test Cases

```python
# tests/unit/services/trade/test_position_sizer.py

import pytest
from decimal import Decimal
from unittest.mock import AsyncMock

from walltrack.services.trade.position_sizer import (
    PositionSizer, SizingMode, SizingConfig, SizingResult
)


class TestRiskBasedSizing:
    """Test risk-based position sizing."""

    @pytest.fixture
    def config(self):
        return SizingConfig(
            sizing_mode=SizingMode.RISK_BASED,
            risk_per_trade_pct=Decimal("1.0"),
            min_position_sol=Decimal("0.1"),
            max_position_sol=Decimal("100"),
            high_conviction_threshold=Decimal("0.85"),
            high_conviction_multiplier=Decimal("1.5"),
        )

    def test_basic_calculation(self, config):
        """1% risk on 1000 SOL with 10% SL = 100 SOL position."""
        sizer = PositionSizer.__new__(PositionSizer)
        result = sizer._calculate_risk_based(
            config=config,
            capital=Decimal("1000"),
            stop_loss_pct=Decimal("10"),
            signal_score=Decimal("0.75"),
        )

        assert result.amount_sol == Decimal("100")
        assert result.risk_amount_sol == Decimal("10")  # 100 * 0.10
        assert result.mode == SizingMode.RISK_BASED
        assert not result.was_capped

    def test_tighter_stop_larger_position(self, config):
        """Tighter SL allows larger position."""
        sizer = PositionSizer.__new__(PositionSizer)
        result = sizer._calculate_risk_based(
            config=config,
            capital=Decimal("1000"),
            stop_loss_pct=Decimal("5"),  # Tighter SL
            signal_score=Decimal("0.75"),
        )

        assert result.amount_sol == Decimal("100")  # Capped at max
        assert result.raw_calculated == Decimal("200")  # Before cap
        assert result.was_capped

    def test_wider_stop_smaller_position(self, config):
        """Wider SL requires smaller position."""
        sizer = PositionSizer.__new__(PositionSizer)
        result = sizer._calculate_risk_based(
            config=config,
            capital=Decimal("1000"),
            stop_loss_pct=Decimal("20"),  # Wider SL
            signal_score=Decimal("0.75"),
        )

        assert result.amount_sol == Decimal("50")  # 10 / 0.20
        assert result.risk_amount_sol == Decimal("10")  # Still 1%
        assert not result.was_capped

    def test_high_conviction_multiplier(self, config):
        """High conviction applies multiplier."""
        sizer = PositionSizer.__new__(PositionSizer)
        result = sizer._calculate_risk_based(
            config=config,
            capital=Decimal("1000"),
            stop_loss_pct=Decimal("10"),
            signal_score=Decimal("0.90"),  # High conviction
        )

        # 100 * 1.5 = 150, but capped at 100
        assert result.amount_sol == Decimal("100")
        assert result.multiplier_applied == Decimal("1.5")
        assert result.was_capped
```

## File List

### New Files
- `src/walltrack/ui/pages/config/sizing_config.py` - Sizing config UI
- `tests/unit/services/trade/test_position_sizer_v2.py` - New tests

### Modified Files
- `src/walltrack/services/trade/position_sizer.py` - Complete refactor
- `src/walltrack/services/config/config_service.py` - Add sizing config getters
