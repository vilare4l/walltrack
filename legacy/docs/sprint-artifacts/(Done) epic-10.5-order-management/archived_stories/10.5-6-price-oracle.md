# Story 10.5.6: Price Oracle - Multi-Source Aggregator

## Story Info
- **Epic**: Epic 10.5 - Order Management, Price Oracle & Risk-Based Sizing
- **Status**: done
- **Priority**: P0 - Critical
- **Story Points**: 5
- **Depends on**: None (peut démarrer en parallèle)

## User Story

**As a** trading system,
**I want** agréger les prix de plusieurs sources,
**So that** j'ai un prix fiable même si une source tombe.

## Acceptance Criteria

### AC 1: Multi-Source Price Fetching
**Given** je demande le prix d'un token
**When** PriceOracle.get_price() est appelé
**Then** il essaie les sources dans l'ordre:
1. DexScreener (priorité 1)
2. Birdeye (priorité 2)
3. Jupiter (priorité 3)
**And** retourne le premier prix valide

### AC 2: Fallback on Failure
**Given** DexScreener est down
**When** get_price() est appelé
**Then** il passe automatiquement à Birdeye
**And** log l'échec de DexScreener
**And** retourne le prix de Birdeye

### AC 3: Price Validation
**Given** un prix est retourné
**When** je valide le résultat
**Then** le prix doit être > 0
**And** le prix doit être dans un range raisonnable (pas de 0.0000001 ni 9999999)
**And** si invalide, passer à la source suivante

### AC 4: Caching with TTL
**Given** un prix est fetché
**When** une nouvelle requête arrive dans les 5 secondes
**Then** le prix caché est retourné
**And** aucun appel API n'est fait
**And** le TTL est configurable

### AC 5: Batch Price Fetching
**Given** j'ai 10 positions actives
**When** je veux leurs prix actuels
**Then** get_prices_batch() groupe les appels
**And** utilise un seul appel API si possible
**And** retourne un dict[token_address, price]

### AC 6: WebSocket/Streaming Support
**Given** des positions actives existent
**When** le price monitor tourne
**Then** les prix sont streamés si la source supporte WebSocket
**And** fallback sur polling si non supporté
**And** fréquence configurable (default 5s)

## Technical Specifications

### Price Oracle Service

**src/walltrack/services/pricing/price_oracle.py:**
```python
"""Multi-source price oracle with fallback."""

from dataclasses import dataclass
from datetime import datetime, timedelta
from decimal import Decimal
from enum import Enum
from typing import Optional, Protocol
import asyncio

import structlog
from cachetools import TTLCache

logger = structlog.get_logger(__name__)


class PriceSource(str, Enum):
    """Available price sources."""
    DEXSCREENER = "dexscreener"
    BIRDEYE = "birdeye"
    JUPITER = "jupiter"


@dataclass
class PriceResult:
    """Result of a price fetch."""
    success: bool
    price: Optional[Decimal] = None
    source: Optional[PriceSource] = None
    timestamp: Optional[datetime] = None
    error: Optional[str] = None

    @property
    def age_seconds(self) -> float:
        """Age of price in seconds."""
        if self.timestamp is None:
            return float('inf')
        return (datetime.utcnow() - self.timestamp).total_seconds()


class PriceProvider(Protocol):
    """Protocol for price providers."""

    async def get_price(self, token_address: str) -> Optional[Decimal]:
        """Get price for a single token."""
        ...

    async def get_prices_batch(
        self,
        token_addresses: list[str]
    ) -> dict[str, Decimal]:
        """Get prices for multiple tokens."""
        ...


class PriceOracle:
    """
    Multi-source price oracle with caching and fallback.

    Fetches prices from multiple sources in priority order
    with automatic fallback on failure.
    """

    # Source priority order
    SOURCE_PRIORITY = [
        PriceSource.DEXSCREENER,
        PriceSource.BIRDEYE,
        PriceSource.JUPITER,
    ]

    # Price validation bounds
    MIN_VALID_PRICE = Decimal("1e-12")
    MAX_VALID_PRICE = Decimal("1e12")

    def __init__(
        self,
        providers: dict[PriceSource, PriceProvider],
        cache_ttl_seconds: int = 5,
        cache_max_size: int = 5000,
    ):
        self.providers = providers
        self.cache_ttl = cache_ttl_seconds
        self._cache: TTLCache = TTLCache(maxsize=cache_max_size, ttl=cache_ttl_seconds)
        self._source_failures: dict[PriceSource, datetime] = {}
        self._failure_cooldown = timedelta(seconds=30)

    async def get_price(self, token_address: str) -> PriceResult:
        """
        Get price for a token with fallback.

        Tries sources in priority order until one succeeds.
        """
        # Check cache first
        cached = self._cache.get(token_address)
        if cached is not None:
            return PriceResult(
                success=True,
                price=cached["price"],
                source=cached["source"],
                timestamp=cached["timestamp"],
            )

        # Try each source in order
        for source in self.SOURCE_PRIORITY:
            # Skip sources in cooldown
            if self._is_source_in_cooldown(source):
                continue

            provider = self.providers.get(source)
            if provider is None:
                continue

            try:
                price = await provider.get_price(token_address)

                if price is not None and self._is_valid_price(price):
                    result = PriceResult(
                        success=True,
                        price=price,
                        source=source,
                        timestamp=datetime.utcnow(),
                    )

                    # Cache the result
                    self._cache[token_address] = {
                        "price": price,
                        "source": source,
                        "timestamp": result.timestamp,
                    }

                    logger.debug(
                        "price_fetched",
                        token=token_address[:8],
                        price=str(price),
                        source=source.value
                    )

                    return result

            except Exception as e:
                logger.warning(
                    "price_source_failed",
                    source=source.value,
                    token=token_address[:8],
                    error=str(e)
                )
                self._mark_source_failed(source)

        # All sources failed
        return PriceResult(
            success=False,
            error="All price sources failed"
        )

    async def get_prices_batch(
        self,
        token_addresses: list[str]
    ) -> dict[str, PriceResult]:
        """
        Get prices for multiple tokens efficiently.

        Uses batch API calls where supported.
        """
        results: dict[str, PriceResult] = {}
        tokens_to_fetch: list[str] = []

        # Check cache first
        for address in token_addresses:
            cached = self._cache.get(address)
            if cached is not None:
                results[address] = PriceResult(
                    success=True,
                    price=cached["price"],
                    source=cached["source"],
                    timestamp=cached["timestamp"],
                )
            else:
                tokens_to_fetch.append(address)

        if not tokens_to_fetch:
            return results

        # Try batch fetch from each source
        for source in self.SOURCE_PRIORITY:
            if not tokens_to_fetch:
                break

            if self._is_source_in_cooldown(source):
                continue

            provider = self.providers.get(source)
            if provider is None:
                continue

            try:
                batch_prices = await provider.get_prices_batch(tokens_to_fetch)

                for address, price in batch_prices.items():
                    if self._is_valid_price(price):
                        now = datetime.utcnow()
                        results[address] = PriceResult(
                            success=True,
                            price=price,
                            source=source,
                            timestamp=now,
                        )

                        self._cache[address] = {
                            "price": price,
                            "source": source,
                            "timestamp": now,
                        }

                        tokens_to_fetch.remove(address)

            except Exception as e:
                logger.warning(
                    "batch_price_source_failed",
                    source=source.value,
                    error=str(e)
                )
                self._mark_source_failed(source)

        # Mark remaining tokens as failed
        for address in tokens_to_fetch:
            results[address] = PriceResult(
                success=False,
                error="All sources failed"
            )

        return results

    def _is_valid_price(self, price: Decimal) -> bool:
        """Check if price is within valid bounds."""
        return self.MIN_VALID_PRICE <= price <= self.MAX_VALID_PRICE

    def _is_source_in_cooldown(self, source: PriceSource) -> bool:
        """Check if source is in failure cooldown."""
        failure_time = self._source_failures.get(source)
        if failure_time is None:
            return False
        return datetime.utcnow() - failure_time < self._failure_cooldown

    def _mark_source_failed(self, source: PriceSource) -> None:
        """Mark source as temporarily failed."""
        self._source_failures[source] = datetime.utcnow()

    def clear_cache(self, token_address: Optional[str] = None) -> None:
        """Clear cache for a specific token or all tokens."""
        if token_address:
            self._cache.pop(token_address, None)
        else:
            self._cache.clear()

    def reset_source_failures(self) -> None:
        """Reset all source failure states."""
        self._source_failures.clear()


# Provider implementations
class DexScreenerProvider(PriceProvider):
    """DexScreener price provider."""

    def __init__(self, api_client):
        self.client = api_client

    async def get_price(self, token_address: str) -> Optional[Decimal]:
        """Get price from DexScreener."""
        data = await self.client.get_token_info(token_address)
        if data and data.get("priceUsd"):
            return Decimal(str(data["priceUsd"]))
        return None

    async def get_prices_batch(
        self,
        token_addresses: list[str]
    ) -> dict[str, Decimal]:
        """Batch fetch from DexScreener."""
        # DexScreener supports up to 30 tokens per request
        results = {}
        for i in range(0, len(token_addresses), 30):
            batch = token_addresses[i:i+30]
            data = await self.client.get_tokens_info(batch)

            for token_data in data:
                address = token_data.get("address")
                price = token_data.get("priceUsd")
                if address and price:
                    results[address] = Decimal(str(price))

        return results


class BirdeyeProvider(PriceProvider):
    """Birdeye price provider."""

    def __init__(self, api_client):
        self.client = api_client

    async def get_price(self, token_address: str) -> Optional[Decimal]:
        """Get price from Birdeye."""
        data = await self.client.get_price(token_address)
        if data and data.get("value"):
            return Decimal(str(data["value"]))
        return None

    async def get_prices_batch(
        self,
        token_addresses: list[str]
    ) -> dict[str, Decimal]:
        """Batch fetch from Birdeye."""
        data = await self.client.get_multi_price(token_addresses)
        return {
            addr: Decimal(str(info["value"]))
            for addr, info in data.items()
            if info.get("value")
        }


class JupiterPriceProvider(PriceProvider):
    """Jupiter price provider."""

    def __init__(self, jupiter_client):
        self.client = jupiter_client

    async def get_price(self, token_address: str) -> Optional[Decimal]:
        """Get price via Jupiter quote."""
        # Get quote for 1 SOL worth
        quote = await self.client.get_quote(
            input_mint="So11111111111111111111111111111111111111112",
            output_mint=token_address,
            amount=1_000_000_000,  # 1 SOL in lamports
        )

        if quote and quote.get("outAmount"):
            # Price = 1 SOL / tokens received
            tokens = Decimal(str(quote["outAmount"])) / Decimal("1e9")
            if tokens > 0:
                return Decimal("1") / tokens

        return None

    async def get_prices_batch(
        self,
        token_addresses: list[str]
    ) -> dict[str, Decimal]:
        """Jupiter doesn't support batch, fall back to individual."""
        results = {}
        tasks = [self.get_price(addr) for addr in token_addresses]
        prices = await asyncio.gather(*tasks, return_exceptions=True)

        for addr, price in zip(token_addresses, prices):
            if isinstance(price, Decimal):
                results[addr] = price

        return results


# Singleton
_price_oracle: Optional[PriceOracle] = None


async def get_price_oracle() -> PriceOracle:
    """Get or create price oracle singleton."""
    global _price_oracle

    if _price_oracle is None:
        from walltrack.services.dexscreener.client import get_dexscreener_client
        from walltrack.services.birdeye.client import get_birdeye_client
        from walltrack.services.jupiter.client import get_jupiter_client

        providers = {
            PriceSource.DEXSCREENER: DexScreenerProvider(
                await get_dexscreener_client()
            ),
            PriceSource.BIRDEYE: BirdeyeProvider(
                await get_birdeye_client()
            ),
            PriceSource.JUPITER: JupiterPriceProvider(
                await get_jupiter_client()
            ),
        }

        _price_oracle = PriceOracle(providers=providers)

    return _price_oracle
```

## Gradio UI Updates

### Price Display Component

**src/walltrack/ui/components/price_display.py:**
```python
"""Real-time price display component."""

import gradio as gr
from decimal import Decimal


def create_price_display():
    """Create price display with source indicator."""

    with gr.Row() as price_row:
        current_price = gr.Number(
            label="Current Price",
            precision=12,
            interactive=False
        )
        price_source = gr.Textbox(
            label="Source",
            max_lines=1,
            interactive=False
        )
        price_age = gr.Textbox(
            label="Age",
            max_lines=1,
            interactive=False
        )

    return price_row, {
        "current_price": current_price,
        "price_source": price_source,
        "price_age": price_age,
    }


async def update_price_display(token_address: str):
    """Update price display for a token."""
    from walltrack.services.pricing.price_oracle import get_price_oracle

    oracle = await get_price_oracle()
    result = await oracle.get_price(token_address)

    if result.success:
        return (
            float(result.price),
            result.source.value,
            f"{result.age_seconds:.1f}s ago"
        )
    else:
        return (0.0, "Error", result.error)
```

## Implementation Tasks

- [x] Create PriceOracle class
- [x] Implement DexScreenerProvider
- [x] Implement BirdeyeProvider
- [x] Implement JupiterPriceProvider
- [x] Add TTL caching with cachetools
- [x] Implement batch price fetching
- [x] Add source failure cooldown
- [x] Add price validation
- [x] Create price display Gradio component
- [x] Write unit tests with mocked providers
- [x] Write integration tests

## Definition of Done

- [x] Prices fetched from DexScreener first
- [x] Automatic fallback to Birdeye/Jupiter
- [x] Cache prevents redundant API calls
- [x] Batch fetching works efficiently
- [x] Failed sources enter cooldown
- [x] Gradio shows price with source
- [x] Full test coverage

## File List

### New Files
- `src/walltrack/services/pricing/__init__.py` - Package init
- `src/walltrack/services/pricing/price_oracle.py` - PriceOracle class
- `src/walltrack/services/pricing/providers.py` - Provider implementations
- `src/walltrack/ui/components/price_display.py` - Price display component
- `tests/unit/services/pricing/test_price_oracle.py` - Oracle tests

### Modified Files
- `src/walltrack/services/__init__.py` - Export pricing module
