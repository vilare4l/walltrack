# Story 10.5.11: Concentration Limits

## Story Info
- **Epic**: Epic 10.5 - Order Management, Price Oracle & Risk-Based Sizing
- **Status**: Done
- **Priority**: P1 - High
- **Story Points**: 3
- **Depends on**: Story 10.5.10 (Daily Loss Limit)
- **Completed**: 2025-12-26

## Implementation Notes

### Completed
- Created `ConcentrationChecker` class with token/cluster concentration enforcement
- Added `ConcentrationMetrics` model to track concentration state
- Added config fields: `max_token_concentration_pct`, `max_cluster_concentration_pct`, `max_positions_per_cluster`, `block_duplicate_positions`
- Integrated with `PositionSizer` as Step 6.6 (after drawdown, before min check)
- 21 unit tests covering all acceptance criteria (AC1-AC4)

### Deferred to Story 10.5-13
- AC5: Gradio Portfolio Allocation UI (consolidated UI story)

## User Story

**As a** portfolio manager,
**I want** limiter la concentration sur un token ou cluster,
**So that** un seul trade ne représente pas un risque excessif.

## Acceptance Criteria

### AC 1: Token Concentration Limit
**Given** max_concentration_token_pct = 25%
**And** portfolio = 100 SOL
**When** j'ai déjà 20 SOL sur TokenA
**Then** une nouvelle entrée sur TokenA est limitée à 5 SOL max
**And** si signal demande plus, il est réduit

### AC 2: Cluster Concentration Limit
**Given** max_concentration_cluster_pct = 50%
**And** cluster "DeFi" a déjà 40 SOL de positions
**When** un nouveau signal DeFi arrive pour 15 SOL
**Then** la position est réduite à 10 SOL
**And** log explique la réduction

### AC 3: Max Positions Per Cluster
**Given** max_positions_per_cluster = 3
**And** j'ai déjà 3 positions dans le cluster "Meme"
**When** un nouveau signal Meme arrive
**Then** l'entrée est bloquée (pas juste réduite)
**And** reason = "Max positions in cluster reached"

### AC 4: Existing Position Check
**Given** j'ai déjà une position ouverte sur TokenB
**When** un nouveau signal pour TokenB arrive
**Then** l'entrée est bloquée
**And** reason = "Position already exists for this token"

### AC 5: Gradio Concentration Display
**Given** je suis sur le dashboard
**When** je regarde la section Portfolio Allocation
**Then** je vois la répartition par token
**And** la répartition par cluster
**And** les tokens/clusters proches des limites sont highlightés

## Technical Specifications

### Concentration Checker

**src/walltrack/services/risk/concentration_checker.py:**
```python
"""Checks and enforces concentration limits."""

from dataclasses import dataclass
from decimal import Decimal
from typing import Optional
from uuid import UUID

import structlog

from walltrack.services.config.config_service import ConfigService, get_config_service

logger = structlog.get_logger(__name__)


@dataclass
class ConcentrationLimits:
    """Configured concentration limits."""
    max_token_pct: Decimal
    max_cluster_pct: Decimal
    max_positions_per_cluster: int


@dataclass
class PositionConcentration:
    """Current concentration for a token/cluster."""
    identifier: str
    current_value_sol: Decimal
    current_pct: Decimal
    limit_pct: Decimal
    remaining_capacity_sol: Decimal
    positions_count: int

    @property
    def is_at_limit(self) -> bool:
        """Check if at or over limit."""
        return self.current_pct >= self.limit_pct

    @property
    def available_pct(self) -> Decimal:
        """Percentage still available."""
        return max(Decimal("0"), self.limit_pct - self.current_pct)


@dataclass
class ConcentrationCheckResult:
    """Result of concentration check."""
    allowed: bool
    max_allowed_sol: Decimal
    adjusted_from: Optional[Decimal] = None
    block_reason: Optional[str] = None
    token_concentration: Optional[PositionConcentration] = None
    cluster_concentration: Optional[PositionConcentration] = None


class ConcentrationChecker:
    """
    Checks portfolio concentration limits.

    Prevents over-concentration in single tokens or clusters.
    """

    def __init__(self, config_service: ConfigService):
        self.config_service = config_service

    async def check_entry(
        self,
        token_address: str,
        cluster_id: Optional[str],
        requested_amount_sol: Decimal,
    ) -> ConcentrationCheckResult:
        """
        Check if entry respects concentration limits.

        Returns adjusted amount if needed, or blocked if not possible.
        """
        log = logger.bind(token=token_address[:8], cluster=cluster_id)

        # Get limits
        limits = await self._get_limits()

        # Get portfolio value
        portfolio_value = await self._get_portfolio_value()

        if portfolio_value <= 0:
            return ConcentrationCheckResult(
                allowed=True,
                max_allowed_sol=requested_amount_sol
            )

        # Check if position already exists
        existing = await self._check_existing_position(token_address)
        if existing:
            log.warning("position_already_exists")
            return ConcentrationCheckResult(
                allowed=False,
                max_allowed_sol=Decimal("0"),
                block_reason="Position already exists for this token"
            )

        # Check token concentration
        token_conc = await self._get_token_concentration(
            token_address, portfolio_value, limits.max_token_pct
        )

        # Check cluster concentration (if cluster specified)
        cluster_conc = None
        if cluster_id:
            cluster_conc = await self._get_cluster_concentration(
                cluster_id, portfolio_value, limits.max_cluster_pct, limits.max_positions_per_cluster
            )

            # Check max positions per cluster
            if cluster_conc.positions_count >= limits.max_positions_per_cluster:
                log.warning(
                    "max_positions_in_cluster",
                    count=cluster_conc.positions_count,
                    limit=limits.max_positions_per_cluster
                )
                return ConcentrationCheckResult(
                    allowed=False,
                    max_allowed_sol=Decimal("0"),
                    block_reason=f"Max positions in cluster reached ({limits.max_positions_per_cluster})",
                    cluster_concentration=cluster_conc
                )

        # Calculate max allowed by token limit
        max_by_token = token_conc.remaining_capacity_sol

        # Calculate max allowed by cluster limit
        max_by_cluster = Decimal("999999")
        if cluster_conc:
            max_by_cluster = cluster_conc.remaining_capacity_sol

        # Take minimum of all limits
        max_allowed = min(max_by_token, max_by_cluster, requested_amount_sol)

        if max_allowed <= Decimal("0"):
            log.warning(
                "concentration_limit_reached",
                token_remaining=str(max_by_token),
                cluster_remaining=str(max_by_cluster)
            )
            return ConcentrationCheckResult(
                allowed=False,
                max_allowed_sol=Decimal("0"),
                block_reason="Concentration limit would be exceeded",
                token_concentration=token_conc,
                cluster_concentration=cluster_conc
            )

        # Check if amount was adjusted
        adjusted_from = None
        if max_allowed < requested_amount_sol:
            adjusted_from = requested_amount_sol
            log.info(
                "position_size_reduced_by_concentration",
                requested=str(requested_amount_sol),
                allowed=str(max_allowed)
            )

        return ConcentrationCheckResult(
            allowed=True,
            max_allowed_sol=max_allowed,
            adjusted_from=adjusted_from,
            token_concentration=token_conc,
            cluster_concentration=cluster_conc
        )

    async def _get_limits(self) -> ConcentrationLimits:
        """Get concentration limits from config."""
        config = await self.config_service.get_trading_config()

        return ConcentrationLimits(
            max_token_pct=Decimal(str(config.max_concentration_token_pct)),
            max_cluster_pct=Decimal(str(config.max_concentration_cluster_pct)),
            max_positions_per_cluster=config.max_positions_per_cluster,
        )

    async def _get_portfolio_value(self) -> Decimal:
        """Get current portfolio value."""
        from walltrack.data.supabase.client import get_supabase_client

        client = await get_supabase_client()

        # Sum of open positions current value
        result = await client.table("positions") \
            .select("entry_amount_sol, unrealized_pnl") \
            .in_("status", ["open", "partial_exit"]) \
            .execute()

        total = Decimal("0")
        for row in result.data:
            entry = Decimal(str(row["entry_amount_sol"]))
            pnl = Decimal(str(row.get("unrealized_pnl", 0) or 0))
            total += entry + pnl

        return total

    async def _check_existing_position(self, token_address: str) -> bool:
        """Check if position already exists for token."""
        from walltrack.data.supabase.client import get_supabase_client

        client = await get_supabase_client()

        result = await client.table("positions") \
            .select("id") \
            .eq("token_address", token_address) \
            .in_("status", ["open", "partial_exit", "exit_pending"]) \
            .limit(1) \
            .execute()

        return len(result.data) > 0

    async def _get_token_concentration(
        self,
        token_address: str,
        portfolio_value: Decimal,
        limit_pct: Decimal
    ) -> PositionConcentration:
        """Get concentration for a specific token."""
        from walltrack.data.supabase.client import get_supabase_client

        client = await get_supabase_client()

        result = await client.table("positions") \
            .select("entry_amount_sol, unrealized_pnl") \
            .eq("token_address", token_address) \
            .in_("status", ["open", "partial_exit"]) \
            .execute()

        current_value = Decimal("0")
        for row in result.data:
            current_value += Decimal(str(row["entry_amount_sol"]))
            current_value += Decimal(str(row.get("unrealized_pnl", 0) or 0))

        current_pct = (current_value / portfolio_value * 100) if portfolio_value > 0 else Decimal("0")
        max_value = portfolio_value * limit_pct / 100
        remaining = max(Decimal("0"), max_value - current_value)

        return PositionConcentration(
            identifier=token_address,
            current_value_sol=current_value,
            current_pct=current_pct,
            limit_pct=limit_pct,
            remaining_capacity_sol=remaining,
            positions_count=len(result.data)
        )

    async def _get_cluster_concentration(
        self,
        cluster_id: str,
        portfolio_value: Decimal,
        limit_pct: Decimal,
        max_positions: int
    ) -> PositionConcentration:
        """Get concentration for a cluster."""
        from walltrack.data.supabase.client import get_supabase_client

        client = await get_supabase_client()

        result = await client.table("positions") \
            .select("entry_amount_sol, unrealized_pnl") \
            .eq("cluster_id", cluster_id) \
            .in_("status", ["open", "partial_exit"]) \
            .execute()

        current_value = Decimal("0")
        for row in result.data:
            current_value += Decimal(str(row["entry_amount_sol"]))
            current_value += Decimal(str(row.get("unrealized_pnl", 0) or 0))

        current_pct = (current_value / portfolio_value * 100) if portfolio_value > 0 else Decimal("0")
        max_value = portfolio_value * limit_pct / 100
        remaining = max(Decimal("0"), max_value - current_value)

        return PositionConcentration(
            identifier=cluster_id,
            current_value_sol=current_value,
            current_pct=current_pct,
            limit_pct=limit_pct,
            remaining_capacity_sol=remaining,
            positions_count=len(result.data)
        )


# Singleton
_checker: Optional[ConcentrationChecker] = None


async def get_concentration_checker() -> ConcentrationChecker:
    """Get or create concentration checker."""
    global _checker
    if _checker is None:
        _checker = ConcentrationChecker(
            config_service=await get_config_service()
        )
    return _checker
```

### Integration with PositionSizer

**src/walltrack/services/risk/position_sizer.py (modification):**
```python
async def calculate_size(
    self,
    signal: Signal,
    current_price: Decimal,
) -> PositionSizeResult:
    """Calculate position size with all risk adjustments."""

    # Step 1: Calculate base size (risk-based or fixed)
    base_result = await self._calculate_base_size(signal, current_price)

    # Step 2: Apply drawdown-based reduction
    from walltrack.services.risk.size_reduction import get_size_reduction_applicator
    reduction_applicator = await get_size_reduction_applicator()
    reduction_result = await reduction_applicator.apply_reduction(base_result.amount_sol)

    if reduction_result.trading_blocked:
        return PositionSizeResult(
            amount_sol=Decimal("0"),
            mode=base_result.mode,
            blocked=True,
            block_reason="Drawdown limit reached",
        )

    # Step 3: Apply concentration limits
    from walltrack.services.risk.concentration_checker import get_concentration_checker
    conc_checker = await get_concentration_checker()
    conc_result = await conc_checker.check_entry(
        token_address=signal.token_address,
        cluster_id=signal.cluster_id,
        requested_amount_sol=reduction_result.reduced_size,
    )

    if not conc_result.allowed:
        return PositionSizeResult(
            amount_sol=Decimal("0"),
            mode=base_result.mode,
            blocked=True,
            block_reason=conc_result.block_reason,
        )

    # Step 4: Return final adjusted size
    return PositionSizeResult(
        amount_sol=conc_result.max_allowed_sol,
        mode=base_result.mode,
        blocked=False,
        original_size=base_result.amount_sol,
        drawdown_reduction_pct=reduction_result.reduction_pct,
        concentration_adjusted=conc_result.adjusted_from is not None,
    )
```

### Gradio Portfolio Allocation Component

**src/walltrack/ui/components/portfolio_allocation.py:**
```python
"""Portfolio allocation display with concentration indicators."""

import gradio as gr
from decimal import Decimal


def create_portfolio_allocation_panel():
    """Create portfolio allocation panel."""

    with gr.Column() as allocation_panel:
        gr.Markdown("### Portfolio Allocation")

        # Token allocation
        with gr.Accordion("By Token", open=True):
            token_table = gr.Dataframe(
                headers=["Token", "Value (SOL)", "% of Portfolio", "Limit", "Status"],
                datatype=["str", "number", "number", "number", "str"],
                label="Token Allocation",
                interactive=False
            )

        # Cluster allocation
        with gr.Accordion("By Cluster", open=True):
            cluster_table = gr.Dataframe(
                headers=["Cluster", "Value (SOL)", "% of Portfolio", "Limit", "Positions", "Status"],
                datatype=["str", "number", "number", "number", "number", "str"],
                label="Cluster Allocation",
                interactive=False
            )

        # Summary stats
        with gr.Row():
            total_positions = gr.Number(
                label="Total Positions",
                precision=0,
                interactive=False
            )
            unique_tokens = gr.Number(
                label="Unique Tokens",
                precision=0,
                interactive=False
            )
            unique_clusters = gr.Number(
                label="Unique Clusters",
                precision=0,
                interactive=False
            )

    return allocation_panel, {
        "token_table": token_table,
        "cluster_table": cluster_table,
        "total_positions": total_positions,
        "unique_tokens": unique_tokens,
        "unique_clusters": unique_clusters,
    }


async def update_portfolio_allocation():
    """Update portfolio allocation display."""
    from walltrack.data.supabase.client import get_supabase_client
    from walltrack.services.config.config_service import get_config_service

    client = await get_supabase_client()
    config_service = await get_config_service()
    config = await config_service.get_trading_config()

    max_token_pct = float(config.max_concentration_token_pct)
    max_cluster_pct = float(config.max_concentration_cluster_pct)
    max_pos_per_cluster = config.max_positions_per_cluster

    # Get open positions
    result = await client.table("positions") \
        .select("token_symbol, token_address, cluster_id, entry_amount_sol, unrealized_pnl") \
        .in_("status", ["open", "partial_exit"]) \
        .execute()

    positions = result.data

    # Calculate total portfolio value
    total_value = sum(
        float(p["entry_amount_sol"]) + float(p.get("unrealized_pnl", 0) or 0)
        for p in positions
    )

    if total_value == 0:
        return [], [], 0, 0, 0

    # Aggregate by token
    token_data = {}
    for p in positions:
        token = p["token_symbol"]
        value = float(p["entry_amount_sol"]) + float(p.get("unrealized_pnl", 0) or 0)

        if token not in token_data:
            token_data[token] = 0
        token_data[token] += value

    token_rows = []
    for token, value in sorted(token_data.items(), key=lambda x: -x[1]):
        pct = (value / total_value) * 100
        status = "OK" if pct < max_token_pct * 0.8 else ("WARNING" if pct < max_token_pct else "LIMIT")
        token_rows.append([token, round(value, 4), round(pct, 1), max_token_pct, status])

    # Aggregate by cluster
    cluster_data = {}
    for p in positions:
        cluster = p.get("cluster_id") or "Unknown"
        value = float(p["entry_amount_sol"]) + float(p.get("unrealized_pnl", 0) or 0)

        if cluster not in cluster_data:
            cluster_data[cluster] = {"value": 0, "count": 0}
        cluster_data[cluster]["value"] += value
        cluster_data[cluster]["count"] += 1

    cluster_rows = []
    for cluster, data in sorted(cluster_data.items(), key=lambda x: -x[1]["value"]):
        value = data["value"]
        count = data["count"]
        pct = (value / total_value) * 100

        if pct >= max_cluster_pct or count >= max_pos_per_cluster:
            status = "LIMIT"
        elif pct >= max_cluster_pct * 0.8 or count >= max_pos_per_cluster - 1:
            status = "WARNING"
        else:
            status = "OK"

        cluster_rows.append([cluster, round(value, 4), round(pct, 1), max_cluster_pct, count, status])

    return (
        token_rows,
        cluster_rows,
        len(positions),
        len(token_data),
        len(cluster_data),
    )
```

## Implementation Tasks

- [x] Create ConcentrationChecker class
- [x] Implement token concentration calculation
- [x] Implement cluster concentration calculation
- [x] Check for existing position on same token
- [x] Integrate with PositionSizer for size adjustment
- [x] Integrate with RiskManager for entry blocking
- [ ] Create Gradio portfolio_allocation panel (deferred to consolidated UI story)
- [ ] Add status indicators (OK/WARNING/LIMIT) (deferred to consolidated UI story)
- [x] Write unit tests (21 tests)
- [x] Write integration tests

## Definition of Done

- [x] Token concentration limits enforced
- [x] Cluster concentration limits enforced
- [x] Max positions per cluster checked
- [x] No duplicate positions on same token
- [x] Sizes adjusted when approaching limits
- [x] Entries blocked when at limits
- [ ] Gradio shows clear allocation view (deferred to Story 10.5-13)
- [x] Full test coverage (21 tests)

## File List

### New Files
- `src/walltrack/services/risk/concentration_checker.py` - Concentration checks
- `src/walltrack/ui/components/portfolio_allocation.py` - Allocation display
- `tests/unit/services/risk/test_concentration.py` - Tests

### Modified Files
- `src/walltrack/services/risk/position_sizer.py` - Integrate concentration limits
- `src/walltrack/services/risk/risk_manager.py` - Add concentration to entry check
- `src/walltrack/ui/pages/dashboard.py` - Add allocation panel
