# Story 10.5.2: Order Table Migration

## Story Info
- **Epic**: Epic 10.5 - Order Management, Price Oracle & Risk-Based Sizing
- **Status**: done
- **Priority**: P0 - Critical
- **Story Points**: 3
- **Depends on**: Story 10.5.1 (Order Model)

## User Story

**As a** database administrator,
**I want** une table orders avec tous les champs nécessaires,
**So that** les ordres sont persistés correctement avec historique complet.

## Acceptance Criteria

### AC 1: Orders Table Creation
**Given** la migration est exécutée
**When** la table orders est créée
**Then** tous les champs du modèle Order sont présents
**And** les types correspondent (UUID, DECIMAL, TIMESTAMPTZ, etc.)
**And** les contraintes sont appliquées

### AC 2: Indexes for Performance
**Given** la table orders existe
**When** des queries sont exécutées
**Then** les indexes optimisent:
- Lookup par status (orders en attente de retry)
- Lookup par position_id (orders d'une position)
- Lookup par signal_id (order d'entrée d'un signal)
- Recherche par date (historique)

### AC 3: Status Constraint
**Given** un insert/update est fait
**When** le status n'est pas valide
**Then** la contrainte CHECK échoue
**And** seuls les status valides sont acceptés

### AC 4: Order History View
**Given** je veux voir l'historique des orders
**When** je query la vue order_history
**Then** je vois les orders avec détails position/signal joints
**And** les stats de retry sont visibles

## Technical Specifications

### Database Migration

**migrations/V9__orders_table.sql:**
```sql
-- WallTrack Orders Table Migration
-- Date: 2024-12-26
-- Purpose: Create orders table for order lifecycle management
-- Version: V9

-- ============================================================
-- PHASE 1: CREATE ORDERS TABLE
-- ============================================================

CREATE TABLE IF NOT EXISTS walltrack.orders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Order Type and Direction
    order_type VARCHAR(10) NOT NULL CHECK (order_type IN ('entry', 'exit')),
    side VARCHAR(10) NOT NULL CHECK (side IN ('buy', 'sell')),

    -- References
    signal_id VARCHAR(100),  -- For ENTRY orders
    position_id UUID,        -- For EXIT orders (references positions table)

    -- Token Info
    token_address VARCHAR(44) NOT NULL,
    token_symbol VARCHAR(20),

    -- Amounts
    amount_sol DECIMAL(20, 8) NOT NULL,
    amount_tokens DECIMAL(30, 8),

    -- Pricing
    expected_price DECIMAL(30, 12) NOT NULL,
    actual_price DECIMAL(30, 12),
    max_slippage_bps INTEGER NOT NULL DEFAULT 100,

    -- Status
    status VARCHAR(20) NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'submitted', 'confirming', 'filled', 'failed', 'cancelled')),

    -- Execution Details
    tx_signature VARCHAR(100),
    filled_at TIMESTAMPTZ,

    -- Retry Management
    attempt_count INTEGER NOT NULL DEFAULT 0,
    max_attempts INTEGER NOT NULL DEFAULT 3,
    last_error TEXT,
    next_retry_at TIMESTAMPTZ,

    -- Simulation Mode
    is_simulated BOOLEAN NOT NULL DEFAULT FALSE,

    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================================
-- PHASE 2: CREATE INDEXES
-- ============================================================

-- Primary lookups
CREATE INDEX IF NOT EXISTS idx_orders_status ON walltrack.orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_position ON walltrack.orders(position_id) WHERE position_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_orders_signal ON walltrack.orders(signal_id) WHERE signal_id IS NOT NULL;

-- Retry worker index (orders needing retry)
CREATE INDEX IF NOT EXISTS idx_orders_retry
    ON walltrack.orders(status, next_retry_at)
    WHERE status = 'failed' AND next_retry_at IS NOT NULL;

-- Active orders (non-terminal)
CREATE INDEX IF NOT EXISTS idx_orders_active
    ON walltrack.orders(created_at DESC)
    WHERE status NOT IN ('filled', 'cancelled');

-- History queries
CREATE INDEX IF NOT EXISTS idx_orders_created ON walltrack.orders(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_orders_filled ON walltrack.orders(filled_at DESC)
    WHERE filled_at IS NOT NULL;

-- Token-based queries
CREATE INDEX IF NOT EXISTS idx_orders_token ON walltrack.orders(token_address);

-- Simulation filtering
CREATE INDEX IF NOT EXISTS idx_orders_simulated ON walltrack.orders(is_simulated, created_at DESC);

-- ============================================================
-- PHASE 3: CREATE UPDATED_AT TRIGGER
-- ============================================================

CREATE OR REPLACE FUNCTION walltrack.update_orders_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_orders_updated ON walltrack.orders;
CREATE TRIGGER trg_orders_updated
    BEFORE UPDATE ON walltrack.orders
    FOR EACH ROW EXECUTE FUNCTION walltrack.update_orders_timestamp();

-- ============================================================
-- PHASE 4: CREATE ORDER HISTORY VIEW
-- ============================================================

CREATE OR REPLACE VIEW walltrack.order_history AS
SELECT
    o.id,
    o.order_type,
    o.side,
    o.token_address,
    o.token_symbol,
    o.amount_sol,
    o.amount_tokens,
    o.expected_price,
    o.actual_price,
    o.status,
    o.tx_signature,
    o.attempt_count,
    o.last_error,
    o.is_simulated,
    o.created_at,
    o.filled_at,

    -- Calculated fields
    CASE
        WHEN o.actual_price IS NOT NULL AND o.expected_price > 0 THEN
            ROUND(ABS(o.actual_price - o.expected_price) / o.expected_price * 10000)
        ELSE NULL
    END AS slippage_bps,

    EXTRACT(EPOCH FROM (COALESCE(o.filled_at, NOW()) - o.created_at)) AS duration_seconds,

    -- Position info (for EXIT orders)
    p.entry_price AS position_entry_price,
    p.entry_amount_sol AS position_entry_sol,

    -- Signal info (for ENTRY orders)
    s.score AS signal_score

FROM walltrack.orders o
LEFT JOIN walltrack.positions p ON o.position_id = p.id
LEFT JOIN walltrack.signals s ON o.signal_id = s.id
ORDER BY o.created_at DESC;

-- ============================================================
-- PHASE 5: CREATE ORDER STATS VIEW
-- ============================================================

CREATE OR REPLACE VIEW walltrack.order_stats AS
SELECT
    is_simulated,
    order_type,
    status,
    COUNT(*) as count,
    AVG(attempt_count) as avg_attempts,
    AVG(CASE WHEN slippage_bps IS NOT NULL THEN slippage_bps ELSE NULL END) as avg_slippage_bps,
    MIN(created_at) as first_order,
    MAX(created_at) as last_order
FROM (
    SELECT
        o.*,
        CASE
            WHEN o.actual_price IS NOT NULL AND o.expected_price > 0 THEN
                ABS(o.actual_price - o.expected_price) / o.expected_price * 10000
            ELSE NULL
        END AS slippage_bps
    FROM walltrack.orders o
) sub
GROUP BY is_simulated, order_type, status;

-- ============================================================
-- PHASE 6: AUDIT LOG INTEGRATION
-- ============================================================

-- Log order status changes to audit log
CREATE OR REPLACE FUNCTION walltrack.log_order_status_change()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        INSERT INTO walltrack.config_audit_log (
            config_table,
            config_key,
            old_value,
            new_value,
            changed_by,
            reason
        ) VALUES (
            'orders',
            NEW.id::TEXT,
            OLD.status,
            NEW.status,
            'system',
            NEW.last_error
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_orders_status_audit ON walltrack.orders;
CREATE TRIGGER trg_orders_status_audit
    AFTER UPDATE ON walltrack.orders
    FOR EACH ROW EXECUTE FUNCTION walltrack.log_order_status_change();
```

### Order Repository

**src/walltrack/data/supabase/repositories/order_repo.py:**
```python
"""Repository for order persistence."""

from datetime import datetime
from typing import Optional
from uuid import UUID

import structlog

from walltrack.data.supabase.client import get_supabase_client
from walltrack.models.order import Order, OrderStatus, OrderType

logger = structlog.get_logger(__name__)


class OrderRepository:
    """Repository for order CRUD operations."""

    async def create(self, order: Order) -> Order:
        """Persist a new order."""
        client = await get_supabase_client()

        data = order.model_dump(mode="json", exclude={"slippage_bps", "can_retry", "is_terminal"})
        # Convert UUID to string
        data["id"] = str(order.id)
        if data.get("position_id"):
            data["position_id"] = str(data["position_id"])

        result = await client.table("orders").insert(data).execute()

        logger.info("order_created", order_id=str(order.id), type=order.order_type.value)
        return order

    async def update(self, order: Order) -> Order:
        """Update an existing order."""
        client = await get_supabase_client()

        data = order.model_dump(mode="json", exclude={"slippage_bps", "can_retry", "is_terminal"})
        data["id"] = str(order.id)
        if data.get("position_id"):
            data["position_id"] = str(data["position_id"])

        await client.table("orders").update(data).eq("id", str(order.id)).execute()

        logger.info(
            "order_updated",
            order_id=str(order.id),
            status=order.status.value
        )
        return order

    async def get_by_id(self, order_id: UUID) -> Optional[Order]:
        """Get order by ID."""
        client = await get_supabase_client()

        result = await client.table("orders").select("*").eq("id", str(order_id)).single().execute()

        if result.data:
            return Order(**result.data)
        return None

    async def get_by_signal(self, signal_id: str) -> Optional[Order]:
        """Get order by signal ID."""
        client = await get_supabase_client()

        result = await client.table("orders").select("*").eq("signal_id", signal_id).single().execute()

        if result.data:
            return Order(**result.data)
        return None

    async def get_by_position(
        self,
        position_id: UUID,
        order_type: Optional[OrderType] = None
    ) -> list[Order]:
        """Get orders for a position."""
        client = await get_supabase_client()

        query = client.table("orders").select("*").eq("position_id", str(position_id))

        if order_type:
            query = query.eq("order_type", order_type.value)

        result = await query.order("created_at", desc=True).execute()

        return [Order(**row) for row in result.data]

    async def get_pending_retries(self, limit: int = 50) -> list[Order]:
        """Get orders ready for retry."""
        client = await get_supabase_client()

        now = datetime.utcnow().isoformat()

        result = await client.table("orders").select("*") \
            .eq("status", "failed") \
            .lte("next_retry_at", now) \
            .lt("attempt_count", 3) \
            .order("next_retry_at") \
            .limit(limit) \
            .execute()

        return [Order(**row) for row in result.data]

    async def get_active_orders(
        self,
        is_simulated: Optional[bool] = None,
        limit: int = 100
    ) -> list[Order]:
        """Get non-terminal orders."""
        client = await get_supabase_client()

        query = client.table("orders").select("*") \
            .not_.in_("status", ["filled", "cancelled"])

        if is_simulated is not None:
            query = query.eq("is_simulated", is_simulated)

        result = await query.order("created_at", desc=True).limit(limit).execute()

        return [Order(**row) for row in result.data]

    async def get_history(
        self,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        order_type: Optional[OrderType] = None,
        status: Optional[OrderStatus] = None,
        is_simulated: Optional[bool] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> list[Order]:
        """Get order history with filters."""
        client = await get_supabase_client()

        query = client.table("orders").select("*")

        if start_date:
            query = query.gte("created_at", start_date.isoformat())
        if end_date:
            query = query.lte("created_at", end_date.isoformat())
        if order_type:
            query = query.eq("order_type", order_type.value)
        if status:
            query = query.eq("status", status.value)
        if is_simulated is not None:
            query = query.eq("is_simulated", is_simulated)

        result = await query \
            .order("created_at", desc=True) \
            .range(offset, offset + limit - 1) \
            .execute()

        return [Order(**row) for row in result.data]

    async def count_by_status(self, is_simulated: Optional[bool] = None) -> dict[str, int]:
        """Count orders by status."""
        client = await get_supabase_client()

        # Use stats view
        query = client.table("order_stats").select("status, count")

        if is_simulated is not None:
            query = query.eq("is_simulated", is_simulated)

        result = await query.execute()

        return {row["status"]: row["count"] for row in result.data}
```

## Implementation Tasks

- [x] Create V9 migration file
- [x] Create orders table with all columns
- [x] Add CHECK constraints for status and types
- [x] Create performance indexes
- [x] Create updated_at trigger
- [x] Create order_history view
- [x] Create order_stats view
- [x] Add audit log trigger
- [x] Create OrderRepository class
- [x] Write migration tests
- [x] Write repository tests

## Definition of Done

- [x] Migration executes without errors
- [x] All indexes are created
- [x] Views return correct data
- [x] Repository CRUD operations work
- [x] Audit log captures status changes
- [x] Tests cover all repository methods

## File List

### New Files
- `migrations/V9__orders_table.sql` - Orders table, indexes, views, triggers
- `src/walltrack/data/supabase/repositories/order_repo.py` - OrderRepository class
- `tests/unit/data/test_order_repo.py` - Repository tests
- `tests/integration/test_orders_migration.py` - Migration tests

### Modified Files
- `src/walltrack/data/supabase/repositories/__init__.py` - Export OrderRepository
