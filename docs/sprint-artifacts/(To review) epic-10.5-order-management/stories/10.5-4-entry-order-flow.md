# Story 10.5.4: Entry Order Flow

## Story Info
- **Epic**: Epic 10.5 - Order Management, Price Oracle & Risk-Based Sizing
- **Status**: done
- **Priority**: P0 - Critical
- **Story Points**: 5
- **Depends on**: Story 10.5.3 (Order Executor)

## User Story

**As a** signal pipeline,
**I want** créer un Order d'entrée au lieu d'une Position directe,
**So that** le trade passe par le cycle de vie complet avec retry.

## Acceptance Criteria

### AC 1: Signal to Order Conversion
**Given** un signal validé (score >= threshold)
**When** le pipeline crée une entrée
**Then** un Order ENTRY est créé (pas une Position directe)
**And** l'Order contient signal_id, token_address, amount_sol
**And** status initial = PENDING

### AC 2: Order Execution
**Given** un Order ENTRY est créé
**When** l'executor le traite
**Then** le flow complet est suivi (PENDING → SUBMITTED → CONFIRMING → FILLED)
**And** seulement quand FILLED, la Position est créée

### AC 3: Position Creation on Fill
**Given** un Order ENTRY passe à FILLED
**When** la confirmation arrive
**Then** une Position est créée automatiquement
**And** Position.entry_order_id = Order.id
**And** Position.entry_price = Order.actual_price
**And** Position.entry_amount_sol = Order.amount_sol

### AC 4: Failure Handling
**Given** un Order ENTRY échoue définitivement (CANCELLED)
**When** les retries sont épuisés
**Then** aucune Position n'est créée
**And** Signal.execution_status = "failed"
**And** une alerte est créée

### AC 5: Integration with Risk Manager
**Given** un signal arrive
**When** l'Order ENTRY est créé
**Then** le RiskManager vérifie:
- Daily loss limit non atteint
- Concentration limits OK
- Drawdown acceptable
**And** l'Order n'est créé que si toutes les conditions passent

## Technical Specifications

### Entry Order Service

**src/walltrack/services/order/entry_service.py:**
```python
"""Service for creating and managing entry orders."""

from decimal import Decimal
from typing import Optional

import structlog

from walltrack.models.order import Order, OrderType, OrderSide, OrderStatus
from walltrack.models.signal import Signal
from walltrack.models.position import Position, PositionStatus
from walltrack.data.supabase.repositories.order_repo import OrderRepository
from walltrack.data.supabase.repositories.position_repo import PositionRepository
from walltrack.data.supabase.repositories.signal_repo import SignalRepository
from walltrack.services.order.executor import OrderExecutor, get_order_executor
from walltrack.services.order.order_factory import OrderFactory
from walltrack.services.risk.risk_manager import RiskManager, get_risk_manager
from walltrack.services.pricing.price_oracle import PriceOracle, get_price_oracle

logger = structlog.get_logger(__name__)


class EntryOrderService:
    """
    Service for handling entry order flow.

    Converts signals to orders and creates positions on fill.
    """

    def __init__(
        self,
        order_repo: OrderRepository,
        position_repo: PositionRepository,
        signal_repo: SignalRepository,
        executor: OrderExecutor,
        risk_manager: RiskManager,
        price_oracle: PriceOracle,
        order_factory: OrderFactory,
    ):
        self.order_repo = order_repo
        self.position_repo = position_repo
        self.signal_repo = signal_repo
        self.executor = executor
        self.risk_manager = risk_manager
        self.price_oracle = price_oracle
        self.order_factory = order_factory

    async def process_signal(self, signal: Signal) -> Optional[Order]:
        """
        Process a validated signal and create entry order.

        Returns:
            Created order if successful, None if blocked by risk management
        """
        log = logger.bind(signal_id=signal.id, token=signal.token_address)

        # Step 1: Risk management checks
        risk_check = await self.risk_manager.check_entry_allowed(
            token_address=signal.token_address,
            cluster_id=signal.cluster_id,
        )

        if not risk_check.allowed:
            log.warning("entry_blocked_by_risk", reason=risk_check.reason)
            await self._update_signal_status(signal, "blocked", risk_check.reason)
            return None

        # Step 2: Get current price
        price_result = await self.price_oracle.get_price(signal.token_address)
        if not price_result.success:
            log.warning("price_fetch_failed", error=price_result.error)
            await self._update_signal_status(signal, "error", "Price fetch failed")
            return None

        expected_price = price_result.price

        # Step 3: Calculate position size
        position_size = await self.risk_manager.calculate_position_size(
            signal=signal,
            current_price=expected_price,
        )

        log.info(
            "position_size_calculated",
            amount_sol=str(position_size.amount_sol),
            sizing_mode=position_size.mode
        )

        # Step 4: Create entry order
        order = self.order_factory.create_entry_order(
            signal=signal,
            amount_sol=position_size.amount_sol,
            expected_price=expected_price,
            max_slippage_bps=100,
        )

        await self.order_repo.create(order)
        log.info("entry_order_created", order_id=str(order.id))

        # Step 5: Execute order
        result = await self.executor.execute(order)

        if result.success:
            # Step 6: Create position
            position = await self._create_position_from_order(order, signal)
            log.info("position_created", position_id=str(position.id))

            await self._update_signal_status(signal, "executed", None)
            return order

        else:
            # Check if can retry
            if order.can_retry:
                log.info("order_scheduled_for_retry", attempt=order.attempt_count)
                # Retry will be handled by RetryWorker
            else:
                log.warning("order_failed_permanently", error=result.error)
                await self._update_signal_status(signal, "failed", result.error)
                await self._create_failure_alert(signal, order)

            return order

    async def _create_position_from_order(
        self,
        order: Order,
        signal: Signal
    ) -> Position:
        """Create a position from a filled entry order."""
        position = Position(
            signal_id=signal.id,
            entry_order_id=str(order.id),
            token_address=order.token_address,
            token_symbol=order.token_symbol,

            # Entry details
            entry_price=order.actual_price,
            entry_amount_sol=order.amount_sol,
            entry_amount_tokens=order.amount_tokens,
            entry_tx=order.tx_signature,
            entry_timestamp=order.filled_at,

            # Status
            status=PositionStatus.OPEN,
            is_simulated=order.is_simulated,

            # Copy signal metadata
            signal_score=signal.score,
            wallet_address=signal.wallet_address,
            cluster_id=signal.cluster_id,
        )

        # Assign exit strategy based on signal score
        position = await self._assign_exit_strategy(position, signal)

        await self.position_repo.create(position)
        return position

    async def _assign_exit_strategy(
        self,
        position: Position,
        signal: Signal
    ) -> Position:
        """Assign exit strategy based on signal conviction."""
        from walltrack.services.strategy.strategy_assigner import get_strategy_assigner

        assigner = await get_strategy_assigner()
        strategy = await assigner.get_strategy_for_score(signal.score)

        position.exit_strategy_id = strategy.id
        position.stop_loss_pct = strategy.stop_loss_pct
        position.take_profit_levels = strategy.take_profit_levels

        return position

    async def _update_signal_status(
        self,
        signal: Signal,
        status: str,
        error: Optional[str]
    ) -> None:
        """Update signal execution status."""
        signal.execution_status = status
        signal.execution_error = error
        await self.signal_repo.update(signal)

    async def _create_failure_alert(
        self,
        signal: Signal,
        order: Order
    ) -> None:
        """Create alert for failed entry."""
        from walltrack.services.alerts.alert_service import get_alert_service

        alert_service = await get_alert_service()
        await alert_service.create_alert(
            alert_type="entry_failed",
            severity="high",
            title=f"Entry order failed for {signal.token_symbol}",
            message=f"Order {order.id} failed after {order.attempt_count} attempts: {order.last_error}",
            data={
                "signal_id": signal.id,
                "order_id": str(order.id),
                "token": signal.token_address,
                "error": order.last_error,
            }
        )


# Singleton
_entry_service: Optional[EntryOrderService] = None


async def get_entry_order_service() -> EntryOrderService:
    """Get or create entry order service."""
    global _entry_service

    if _entry_service is None:
        from walltrack.core.config import get_settings

        settings = get_settings()

        _entry_service = EntryOrderService(
            order_repo=OrderRepository(),
            position_repo=PositionRepository(),
            signal_repo=SignalRepository(),
            executor=await get_order_executor(),
            risk_manager=await get_risk_manager(),
            price_oracle=await get_price_oracle(),
            order_factory=OrderFactory(is_simulation_mode=settings.simulation_mode),
        )

    return _entry_service
```

### Pipeline Integration

**src/walltrack/services/signal/pipeline.py (modification):**
```python
"""Signal pipeline with order integration."""

# Dans la méthode process_signal existante, remplacer:
# OLD:
# position = await self.trade_executor.execute_entry(signal, position_size)

# NEW:
async def _execute_entry(self, signal: Signal) -> bool:
    """Execute entry via order flow."""
    from walltrack.services.order.entry_service import get_entry_order_service

    entry_service = await get_entry_order_service()
    order = await entry_service.process_signal(signal)

    if order is None:
        return False

    return order.status == OrderStatus.FILLED
```

## Gradio UI Updates

### Signal Detail with Order Status

**src/walltrack/ui/components/signal_detail.py:**
```python
"""Signal detail component with order status."""

import gradio as gr

from walltrack.models.signal import Signal
from walltrack.models.order import Order, OrderStatus


def create_signal_detail_component():
    """Create signal detail with order tracking."""

    with gr.Column() as signal_detail:
        gr.Markdown("### Signal Details")

        with gr.Row():
            signal_id = gr.Textbox(label="Signal ID", interactive=False)
            token_symbol = gr.Textbox(label="Token", interactive=False)
            score = gr.Number(label="Score", interactive=False)

        with gr.Row():
            execution_status = gr.Textbox(label="Execution Status", interactive=False)
            order_status = gr.Textbox(label="Order Status", interactive=False)
            attempts = gr.Number(label="Attempts", interactive=False)

        with gr.Row():
            error_msg = gr.Textbox(
                label="Error Message",
                interactive=False,
                visible=False
            )

        retry_btn = gr.Button("Retry Order", visible=False)

    return signal_detail, {
        "signal_id": signal_id,
        "token_symbol": token_symbol,
        "score": score,
        "execution_status": execution_status,
        "order_status": order_status,
        "attempts": attempts,
        "error_msg": error_msg,
        "retry_btn": retry_btn,
    }
```

## Implementation Tasks

- [x] Create EntryOrderService class
- [x] Integrate with RiskManager for entry checks
- [x] Integrate with PriceOracle for current price
- [x] Create position from filled order
- [x] Assign exit strategy based on signal score
- [x] Update signal status on success/failure
- [x] Create failure alerts
- [x] Modify signal pipeline to use order flow
- [x] Add Gradio signal detail with order status
- [x] Write unit tests
- [x] Write integration tests

## Definition of Done

- [x] Signals create Orders instead of Positions directly
- [x] Positions created only when Order is FILLED
- [x] Risk checks block entries when appropriate
- [x] Failed entries create alerts
- [x] Signal status reflects order outcome
- [x] Gradio shows order status for signals
- [x] Full test coverage

## File List

### New Files
- `src/walltrack/services/order/entry_service.py` - EntryOrderService
- `src/walltrack/ui/components/signal_detail.py` - Signal detail component
- `tests/unit/services/order/test_entry_service.py` - Entry service tests

### Modified Files
- `src/walltrack/services/signal/pipeline.py` - Use order flow instead of direct execution
- `src/walltrack/ui/pages/signals.py` - Add order status display
