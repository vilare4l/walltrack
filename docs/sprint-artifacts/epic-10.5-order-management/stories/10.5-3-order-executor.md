# Story 10.5.3: Order Executor with Retry Logic

## Story Info
- **Epic**: Epic 10.5 - Order Management, Price Oracle & Risk-Based Sizing
- **Status**: ready
- **Priority**: P0 - Critical
- **Story Points**: 8
- **Depends on**: Story 10.5.1 (Order Model), Story 10.5.2 (Order Table)

## User Story

**As a** trading system,
**I want** un executor qui gère les retries automatiquement,
**So that** les trades ont plusieurs chances de réussir avant d'échouer définitivement.

## Acceptance Criteria

### AC 1: Order Execution Flow
**Given** un Order en status PENDING
**When** l'executor le traite
**Then** il passe par les états: PENDING → SUBMITTED → CONFIRMING → FILLED
**And** chaque transition est persistée en base
**And** les logs structurés tracent chaque étape

### AC 2: Jupiter Integration
**Given** un Order de type ENTRY (BUY)
**When** l'executor appelle Jupiter
**Then** il obtient un quote avec le slippage configuré
**And** il crée une transaction swap
**And** il signe et envoie la transaction
**And** il attend la confirmation (60s timeout)

### AC 3: Error Handling with Retry
**Given** une erreur survient pendant l'exécution
**When** l'ordre échoue
**Then** attempt_count est incrémenté
**And** last_error contient le message
**And** next_retry_at est calculé si retries restants
**And** status passe à FAILED

### AC 4: Simulation Mode
**Given** is_simulated = True
**When** l'ordre est exécuté
**Then** aucune transaction réelle n'est envoyée
**And** le prix simulé est le expected_price
**And** un délai artificiel simule le temps d'exécution
**And** l'ordre passe à FILLED

### AC 5: Concurrent Execution
**Given** plusieurs ordres sont en attente
**When** l'executor traite
**Then** les ordres sont traités séquentiellement par défaut
**And** une option permet le traitement parallèle (max 3 concurrent)

## Technical Specifications

### Order Executor Service

**src/walltrack/services/order/executor.py:**
```python
"""Order executor with retry logic."""

import asyncio
from datetime import datetime
from decimal import Decimal
from typing import Optional, Protocol

import structlog

from walltrack.models.order import Order, OrderStatus
from walltrack.data.supabase.repositories.order_repo import OrderRepository
from walltrack.services.jupiter.client import JupiterClient, JupiterError
from walltrack.services.wallet.trading_wallet import TradingWallet

logger = structlog.get_logger(__name__)


class OrderResult:
    """Result of order execution attempt."""

    def __init__(
        self,
        success: bool,
        order: Order,
        tx_signature: Optional[str] = None,
        actual_price: Optional[Decimal] = None,
        error: Optional[str] = None,
    ):
        self.success = success
        self.order = order
        self.tx_signature = tx_signature
        self.actual_price = actual_price
        self.error = error


class OrderExecutor:
    """
    Executes orders against Jupiter DEX.

    Handles the full lifecycle:
    - Quote fetching
    - Transaction creation
    - Signing and sending
    - Confirmation waiting
    - Retry on failure
    """

    def __init__(
        self,
        repository: OrderRepository,
        jupiter_client: JupiterClient,
        trading_wallet: TradingWallet,
        confirmation_timeout: int = 60,
        max_concurrent: int = 1,
    ):
        self.repository = repository
        self.jupiter = jupiter_client
        self.wallet = trading_wallet
        self.confirmation_timeout = confirmation_timeout
        self.max_concurrent = max_concurrent
        self._semaphore = asyncio.Semaphore(max_concurrent)

    async def execute(self, order: Order) -> OrderResult:
        """
        Execute a single order.

        Handles the full flow from PENDING to FILLED/FAILED.
        """
        async with self._semaphore:
            if order.is_simulated:
                return await self._execute_simulated(order)
            else:
                return await self._execute_real(order)

    async def _execute_real(self, order: Order) -> OrderResult:
        """Execute order against Jupiter."""
        log = logger.bind(order_id=str(order.id), token=order.token_address)

        try:
            # Step 1: Mark as submitted
            order.mark_submitted()
            await self.repository.update(order)
            log.info("order_submitted")

            # Step 2: Get quote from Jupiter
            quote = await self._get_quote(order)
            log.info("quote_received", output_amount=str(quote.output_amount))

            # Step 3: Create and send transaction
            tx_signature = await self._create_and_send_tx(order, quote)

            # Step 4: Mark as confirming
            order.mark_confirming(tx_signature)
            await self.repository.update(order)
            log.info("tx_sent", tx_signature=tx_signature)

            # Step 5: Wait for confirmation
            confirmed = await self._wait_for_confirmation(tx_signature)

            if confirmed:
                # Step 6: Get actual execution price
                actual_price = await self._get_execution_price(tx_signature, order)

                order.mark_filled(actual_price, quote.output_amount)
                await self.repository.update(order)

                log.info(
                    "order_filled",
                    actual_price=str(actual_price),
                    slippage_bps=order.slippage_bps
                )

                return OrderResult(
                    success=True,
                    order=order,
                    tx_signature=tx_signature,
                    actual_price=actual_price
                )
            else:
                raise JupiterError("Transaction confirmation timeout")

        except Exception as e:
            error_msg = str(e)
            log.warning("order_failed", error=error_msg, attempt=order.attempt_count + 1)

            order.mark_failed(error_msg)
            await self.repository.update(order)

            return OrderResult(
                success=False,
                order=order,
                error=error_msg
            )

    async def _execute_simulated(self, order: Order) -> OrderResult:
        """Execute in simulation mode (no real transaction)."""
        log = logger.bind(order_id=str(order.id), simulated=True)

        # Simulate execution delay
        await asyncio.sleep(0.5)

        order.mark_submitted()
        await self.repository.update(order)

        # Simulate confirmation delay
        await asyncio.sleep(1.0)

        fake_signature = f"sim_{order.id}_{datetime.utcnow().timestamp()}"
        order.mark_confirming(fake_signature)

        # Use expected price as actual (no slippage in simulation)
        order.mark_filled(order.expected_price, order.amount_tokens)
        await self.repository.update(order)

        log.info("simulated_order_filled", price=str(order.expected_price))

        return OrderResult(
            success=True,
            order=order,
            tx_signature=fake_signature,
            actual_price=order.expected_price
        )

    async def _get_quote(self, order: Order) -> "JupiterQuote":
        """Get quote from Jupiter."""
        # Determine input/output based on order side
        if order.side.value == "buy":
            input_mint = "So11111111111111111111111111111111111111112"  # SOL
            output_mint = order.token_address
            amount = int(order.amount_sol * Decimal("1e9"))  # lamports
        else:
            input_mint = order.token_address
            output_mint = "So11111111111111111111111111111111111111112"
            amount = int(order.amount_tokens * Decimal("1e9"))  # token decimals

        quote = await self.jupiter.get_quote(
            input_mint=input_mint,
            output_mint=output_mint,
            amount=amount,
            slippage_bps=order.max_slippage_bps
        )

        return quote

    async def _create_and_send_tx(self, order: Order, quote) -> str:
        """Create swap transaction and send it."""
        # Get swap transaction from Jupiter
        swap_tx = await self.jupiter.get_swap_transaction(
            quote=quote,
            user_public_key=str(self.wallet.public_key)
        )

        # Sign transaction
        signed_tx = await self.wallet.sign_transaction(swap_tx)

        # Send transaction
        tx_signature = await self.jupiter.send_transaction(signed_tx)

        return tx_signature

    async def _wait_for_confirmation(self, tx_signature: str) -> bool:
        """Wait for transaction confirmation."""
        start_time = datetime.utcnow()

        while (datetime.utcnow() - start_time).total_seconds() < self.confirmation_timeout:
            status = await self.jupiter.get_transaction_status(tx_signature)

            if status == "confirmed":
                return True
            elif status == "failed":
                return False

            await asyncio.sleep(2)

        return False

    async def _get_execution_price(
        self,
        tx_signature: str,
        order: Order
    ) -> Decimal:
        """Get actual execution price from transaction."""
        tx_details = await self.jupiter.get_transaction_details(tx_signature)

        if tx_details and tx_details.get("price"):
            return Decimal(str(tx_details["price"]))

        # Fallback to expected price if we can't determine actual
        return order.expected_price

    async def execute_batch(self, orders: list[Order]) -> list[OrderResult]:
        """Execute multiple orders (respects max_concurrent)."""
        tasks = [self.execute(order) for order in orders]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        final_results = []
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                final_results.append(OrderResult(
                    success=False,
                    order=orders[i],
                    error=str(result)
                ))
            else:
                final_results.append(result)

        return final_results


# Singleton instance
_executor: Optional[OrderExecutor] = None


async def get_order_executor() -> OrderExecutor:
    """Get or create order executor singleton."""
    global _executor

    if _executor is None:
        from walltrack.data.supabase.repositories.order_repo import OrderRepository
        from walltrack.services.jupiter.client import get_jupiter_client
        from walltrack.services.wallet.trading_wallet import get_trading_wallet

        _executor = OrderExecutor(
            repository=OrderRepository(),
            jupiter_client=await get_jupiter_client(),
            trading_wallet=await get_trading_wallet(),
        )

    return _executor
```

### Mock Executor for Testing

**src/walltrack/services/order/mock_executor.py:**
```python
"""Mock order executor for testing and simulation."""

import asyncio
from decimal import Decimal
from typing import Optional
import random

from walltrack.models.order import Order
from walltrack.services.order.executor import OrderResult


class MockOrderExecutor:
    """
    Mock executor for testing.

    Simulates order execution with configurable behavior.
    """

    def __init__(
        self,
        success_rate: float = 1.0,
        avg_slippage_bps: int = 50,
        execution_delay: float = 0.1,
    ):
        self.success_rate = success_rate
        self.avg_slippage_bps = avg_slippage_bps
        self.execution_delay = execution_delay
        self.executed_orders: list[Order] = []

    async def execute(self, order: Order) -> OrderResult:
        """Simulate order execution."""
        await asyncio.sleep(self.execution_delay)

        self.executed_orders.append(order)

        # Simulate random failures based on success rate
        if random.random() > self.success_rate:
            order.mark_submitted()
            order.mark_failed("Simulated failure")
            return OrderResult(
                success=False,
                order=order,
                error="Simulated failure"
            )

        # Simulate slippage
        slippage_factor = 1 + (self.avg_slippage_bps / 10000 * random.uniform(0.5, 1.5))

        if order.side.value == "buy":
            actual_price = order.expected_price * Decimal(str(slippage_factor))
        else:
            actual_price = order.expected_price / Decimal(str(slippage_factor))

        order.mark_submitted()
        order.mark_confirming(f"mock_tx_{order.id}")
        order.mark_filled(actual_price)

        return OrderResult(
            success=True,
            order=order,
            tx_signature=f"mock_tx_{order.id}",
            actual_price=actual_price
        )

    def reset(self):
        """Reset execution history."""
        self.executed_orders = []
```

## Implementation Tasks

- [ ] Create OrderExecutor class
- [ ] Implement _execute_real with Jupiter integration
- [ ] Implement _execute_simulated for simulation mode
- [ ] Implement quote fetching from Jupiter
- [ ] Implement transaction creation and signing
- [ ] Implement confirmation waiting with timeout
- [ ] Implement actual price extraction
- [ ] Add concurrency control with semaphore
- [ ] Create MockOrderExecutor for testing
- [ ] Add structured logging throughout
- [ ] Write unit tests with mocked Jupiter
- [ ] Write integration tests

## Definition of Done

- [ ] Orders execute through full lifecycle
- [ ] Jupiter API errors are caught and retried
- [ ] Simulation mode works without real transactions
- [ ] Concurrency is controlled
- [ ] All transitions are persisted
- [ ] Comprehensive test coverage

## Test Cases

```python
# tests/unit/services/order/test_executor.py

import pytest
from decimal import Decimal
from unittest.mock import AsyncMock, MagicMock, patch

from walltrack.models.order import Order, OrderType, OrderSide, OrderStatus
from walltrack.services.order.executor import OrderExecutor, OrderResult


@pytest.fixture
def mock_repository():
    repo = AsyncMock()
    repo.update = AsyncMock()
    return repo


@pytest.fixture
def mock_jupiter():
    jupiter = AsyncMock()
    jupiter.get_quote = AsyncMock(return_value=MagicMock(output_amount=Decimal("1000")))
    jupiter.get_swap_transaction = AsyncMock(return_value=b"tx_bytes")
    jupiter.send_transaction = AsyncMock(return_value="tx_sig_123")
    jupiter.get_transaction_status = AsyncMock(return_value="confirmed")
    jupiter.get_transaction_details = AsyncMock(return_value={"price": "0.001"})
    return jupiter


@pytest.fixture
def mock_wallet():
    wallet = AsyncMock()
    wallet.public_key = "wallet_pubkey"
    wallet.sign_transaction = AsyncMock(return_value=b"signed_tx")
    return wallet


@pytest.fixture
def executor(mock_repository, mock_jupiter, mock_wallet):
    return OrderExecutor(
        repository=mock_repository,
        jupiter_client=mock_jupiter,
        trading_wallet=mock_wallet,
        confirmation_timeout=5,
    )


class TestOrderExecution:
    """Test order execution flow."""

    @pytest.mark.asyncio
    async def test_successful_execution(self, executor, mock_repository):
        """Order executes successfully through all states."""
        order = Order(
            order_type=OrderType.ENTRY,
            side=OrderSide.BUY,
            token_address="token123",
            amount_sol=Decimal("1.0"),
            expected_price=Decimal("0.001"),
        )

        result = await executor.execute(order)

        assert result.success is True
        assert result.order.status == OrderStatus.FILLED
        assert result.tx_signature == "tx_sig_123"
        assert result.actual_price == Decimal("0.001")

        # Verify state transitions were persisted
        assert mock_repository.update.call_count >= 2

    @pytest.mark.asyncio
    async def test_simulated_execution(self, executor, mock_repository):
        """Simulated order doesn't call Jupiter."""
        order = Order(
            order_type=OrderType.ENTRY,
            side=OrderSide.BUY,
            token_address="token123",
            amount_sol=Decimal("1.0"),
            expected_price=Decimal("0.001"),
            is_simulated=True,
        )

        result = await executor.execute(order)

        assert result.success is True
        assert result.order.status == OrderStatus.FILLED
        assert "sim_" in result.tx_signature

    @pytest.mark.asyncio
    async def test_execution_failure_triggers_retry(self, executor, mock_jupiter, mock_repository):
        """Failed execution schedules retry."""
        mock_jupiter.get_quote = AsyncMock(side_effect=Exception("API Error"))

        order = Order(
            order_type=OrderType.ENTRY,
            side=OrderSide.BUY,
            token_address="token123",
            amount_sol=Decimal("1.0"),
            expected_price=Decimal("0.001"),
        )

        result = await executor.execute(order)

        assert result.success is False
        assert result.order.status == OrderStatus.FAILED
        assert result.order.attempt_count == 1
        assert result.order.can_retry is True
        assert result.error == "API Error"
```

## File List

### New Files
- `src/walltrack/services/order/executor.py` - OrderExecutor class
- `src/walltrack/services/order/mock_executor.py` - MockOrderExecutor for testing
- `tests/unit/services/order/test_executor.py` - Executor tests
- `tests/integration/test_order_execution.py` - Integration tests

### Modified Files
- `src/walltrack/services/order/__init__.py` - Export OrderExecutor
