# Story 10.5.14: Alerts on Order Failures

## Story Info
- **Epic**: Epic 10.5 - Order Management, Price Oracle & Risk-Based Sizing
- **Status**: ready
- **Priority**: P1 - High
- **Story Points**: 3
- **Depends on**: Story 10.5.12 (Retry Worker)

## User Story

**As a** trader,
**I want** recevoir des alertes en cas d'échec d'ordre,
**So that** je suis informé des problèmes nécessitant attention.

## Acceptance Criteria

### AC 1: Alert on Permanent Failure
**Given** un ordre atteint max_attempts (3)
**When** le dernier retry échoue
**Then** une alerte CRITICAL est créée
**And** titre = "Order Failed - Manual Action Required"
**And** contient: order_id, token, error, position_id

### AC 2: Alert on Exit Failure (Higher Priority)
**Given** un EXIT order échoue définitivement
**When** l'alerte est créée
**Then** severity = CRITICAL (vs HIGH pour ENTRY)
**And** message insiste sur l'urgence
**And** requires_action = true

### AC 3: Alert Deduplication
**Given** une alerte existe déjà pour cet ordre
**When** un nouveau retry échoue
**Then** l'alerte existante est mise à jour
**And** attempt count est incrémenté
**And** pas de nouvelle alerte créée

### AC 4: Alert Resolution
**Given** une alerte existe pour un ordre
**When** l'ordre est finalement FILLED ou manuellement CANCELLED
**Then** l'alerte est marquée resolved
**And** resolved_at et resolution sont enregistrés

### AC 5: Gradio Alert Display
**Given** je suis sur le dashboard
**When** des alertes actives existent
**Then** un badge compte les alertes non résolues
**And** les alertes CRITICAL sont highlighted
**And** je peux voir le détail et agir

### AC 6: Alert Notification
**Given** une alerte CRITICAL est créée
**When** l'alerte est persistée
**Then** un event est émis pour notification externe (webhook future)
**And** le timestamp est enregistré

## Technical Specifications

### Alert Model

**src/walltrack/models/alert.py:**
```python
"""Alert model for system notifications."""

from datetime import datetime
from enum import Enum
from typing import Optional
from uuid import UUID, uuid4

from pydantic import BaseModel, Field


class AlertSeverity(str, Enum):
    """Alert severity levels."""
    INFO = "info"
    WARNING = "warning"
    HIGH = "high"
    CRITICAL = "critical"


class AlertStatus(str, Enum):
    """Alert status."""
    ACTIVE = "active"
    ACKNOWLEDGED = "acknowledged"
    RESOLVED = "resolved"


class Alert(BaseModel):
    """System alert."""
    id: UUID = Field(default_factory=uuid4)
    alert_type: str
    severity: AlertSeverity
    status: AlertStatus = AlertStatus.ACTIVE
    title: str
    message: str
    data: dict = Field(default_factory=dict)

    # Tracking
    requires_action: bool = False
    dedupe_key: Optional[str] = None

    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow)
    acknowledged_at: Optional[datetime] = None
    acknowledged_by: Optional[str] = None
    resolved_at: Optional[datetime] = None
    resolution: Optional[str] = None

    # Notification tracking
    notified_at: Optional[datetime] = None

    @property
    def is_active(self) -> bool:
        """Check if alert is active."""
        return self.status == AlertStatus.ACTIVE

    @property
    def age_hours(self) -> float:
        """Age of alert in hours."""
        return (datetime.utcnow() - self.created_at).total_seconds() / 3600
```

### Alert Service

**src/walltrack/services/alerts/alert_service.py:**
```python
"""Alert service for creating and managing alerts."""

from datetime import datetime
from typing import Optional

import structlog

from walltrack.models.alert import Alert, AlertSeverity, AlertStatus

logger = structlog.get_logger(__name__)


class AlertService:
    """
    Service for managing system alerts.

    Handles creation, deduplication, and resolution of alerts.
    """

    async def create_alert(
        self,
        alert_type: str,
        severity: str,
        title: str,
        message: str,
        data: dict = None,
        requires_action: bool = False,
        dedupe_key: Optional[str] = None,
    ) -> Alert:
        """
        Create a new alert or update existing if dedupe_key matches.

        Args:
            alert_type: Type of alert (e.g., "order_failed")
            severity: Alert severity level
            title: Alert title
            message: Detailed message
            data: Additional context data
            requires_action: Whether user action is required
            dedupe_key: Key for deduplication

        Returns:
            Created or updated alert
        """
        from walltrack.data.supabase.client import get_supabase_client

        client = await get_supabase_client()
        log = logger.bind(alert_type=alert_type, severity=severity)

        # Check for existing alert with same dedupe_key
        if dedupe_key:
            existing = await self._find_by_dedupe_key(client, dedupe_key)

            if existing:
                log.debug("updating_existing_alert", alert_id=existing["id"])
                return await self._update_alert(
                    client, existing["id"], message, data
                )

        # Create new alert
        alert = Alert(
            alert_type=alert_type,
            severity=AlertSeverity(severity),
            title=title,
            message=message,
            data=data or {},
            requires_action=requires_action,
            dedupe_key=dedupe_key,
        )

        await client.table("alerts").insert({
            "id": str(alert.id),
            "alert_type": alert.alert_type,
            "severity": alert.severity.value,
            "status": alert.status.value,
            "title": alert.title,
            "message": alert.message,
            "data": alert.data,
            "requires_action": alert.requires_action,
            "dedupe_key": alert.dedupe_key,
            "created_at": alert.created_at.isoformat(),
        }).execute()

        log.info("alert_created", alert_id=str(alert.id), title=title)

        # Emit notification event
        await self._emit_notification_event(alert)

        return alert

    async def acknowledge_alert(
        self,
        alert_id: str,
        acknowledged_by: str = "user"
    ) -> bool:
        """Mark an alert as acknowledged."""
        from walltrack.data.supabase.client import get_supabase_client

        client = await get_supabase_client()

        result = await client.table("alerts").update({
            "status": AlertStatus.ACKNOWLEDGED.value,
            "acknowledged_at": datetime.utcnow().isoformat(),
            "acknowledged_by": acknowledged_by,
        }).eq("id", alert_id).execute()

        success = len(result.data) > 0
        if success:
            logger.info("alert_acknowledged", alert_id=alert_id)

        return success

    async def resolve_alert(
        self,
        alert_id: str,
        resolution: str
    ) -> bool:
        """Mark an alert as resolved."""
        from walltrack.data.supabase.client import get_supabase_client

        client = await get_supabase_client()

        result = await client.table("alerts").update({
            "status": AlertStatus.RESOLVED.value,
            "resolved_at": datetime.utcnow().isoformat(),
            "resolution": resolution,
        }).eq("id", alert_id).execute()

        success = len(result.data) > 0
        if success:
            logger.info("alert_resolved", alert_id=alert_id, resolution=resolution)

        return success

    async def resolve_by_dedupe_key(
        self,
        dedupe_key: str,
        resolution: str
    ) -> bool:
        """Resolve alert by dedupe key."""
        from walltrack.data.supabase.client import get_supabase_client

        client = await get_supabase_client()

        result = await client.table("alerts").update({
            "status": AlertStatus.RESOLVED.value,
            "resolved_at": datetime.utcnow().isoformat(),
            "resolution": resolution,
        }).eq("dedupe_key", dedupe_key).eq("status", AlertStatus.ACTIVE.value).execute()

        return len(result.data) > 0

    async def get_active_alerts(
        self,
        severity: Optional[str] = None,
        limit: int = 50
    ) -> list[Alert]:
        """Get active alerts."""
        from walltrack.data.supabase.client import get_supabase_client

        client = await get_supabase_client()

        query = client.table("alerts").select("*") \
            .in_("status", [AlertStatus.ACTIVE.value, AlertStatus.ACKNOWLEDGED.value])

        if severity:
            query = query.eq("severity", severity)

        result = await query \
            .order("created_at", desc=True) \
            .limit(limit) \
            .execute()

        return [Alert(**row) for row in result.data]

    async def get_active_count(self) -> dict:
        """Get count of active alerts by severity."""
        from walltrack.data.supabase.client import get_supabase_client

        client = await get_supabase_client()

        result = await client.table("alerts").select("severity") \
            .eq("status", AlertStatus.ACTIVE.value) \
            .execute()

        counts = {s.value: 0 for s in AlertSeverity}
        for row in result.data:
            counts[row["severity"]] = counts.get(row["severity"], 0) + 1

        counts["total"] = len(result.data)
        return counts

    async def _find_by_dedupe_key(self, client, dedupe_key: str) -> Optional[dict]:
        """Find active alert by dedupe key."""
        result = await client.table("alerts").select("*") \
            .eq("dedupe_key", dedupe_key) \
            .eq("status", AlertStatus.ACTIVE.value) \
            .single() \
            .execute()

        return result.data

    async def _update_alert(
        self,
        client,
        alert_id: str,
        message: str,
        data: dict
    ) -> Alert:
        """Update existing alert."""
        result = await client.table("alerts").update({
            "message": message,
            "data": data,
            "updated_at": datetime.utcnow().isoformat(),
        }).eq("id", alert_id).execute()

        return Alert(**result.data[0])

    async def _emit_notification_event(self, alert: Alert) -> None:
        """Emit notification event for external systems."""
        # For now, just log. Future: webhook, email, etc.
        if alert.severity in [AlertSeverity.CRITICAL, AlertSeverity.HIGH]:
            logger.warning(
                "notification_event",
                alert_id=str(alert.id),
                severity=alert.severity.value,
                title=alert.title
            )


# Singleton
_alert_service: Optional[AlertService] = None


async def get_alert_service() -> AlertService:
    """Get or create alert service."""
    global _alert_service
    if _alert_service is None:
        _alert_service = AlertService()
    return _alert_service
```

### Alert Database Migration

**migrations/V12__alerts.sql:**
```sql
-- Alerts table
CREATE TABLE IF NOT EXISTS walltrack.alerts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    alert_type VARCHAR(50) NOT NULL,
    severity VARCHAR(20) NOT NULL CHECK (severity IN ('info', 'warning', 'high', 'critical')),
    status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'acknowledged', 'resolved')),

    title VARCHAR(255) NOT NULL,
    message TEXT NOT NULL,
    data JSONB DEFAULT '{}',

    requires_action BOOLEAN DEFAULT FALSE,
    dedupe_key VARCHAR(255),

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    acknowledged_at TIMESTAMPTZ,
    acknowledged_by VARCHAR(100),
    resolved_at TIMESTAMPTZ,
    resolution TEXT,
    notified_at TIMESTAMPTZ,

    -- Indexes
    CONSTRAINT uq_alert_dedupe UNIQUE (dedupe_key, status) WHERE status = 'active'
);

CREATE INDEX IF NOT EXISTS idx_alerts_status ON walltrack.alerts(status);
CREATE INDEX IF NOT EXISTS idx_alerts_severity ON walltrack.alerts(severity, status);
CREATE INDEX IF NOT EXISTS idx_alerts_created ON walltrack.alerts(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_alerts_dedupe ON walltrack.alerts(dedupe_key) WHERE status = 'active';
```

### Order Alert Integration

**src/walltrack/services/order/retry_worker.py (modification):**
```python
async def _handle_max_attempts_reached(self, order: Order) -> None:
    """Handle order that has exhausted all retries."""
    from walltrack.services.alerts.alert_service import get_alert_service

    alert_service = await get_alert_service()

    # Higher severity for EXIT orders
    severity = "critical" if order.order_type == OrderType.EXIT else "high"

    await alert_service.create_alert(
        alert_type="order_failed_permanently",
        severity=severity,
        title=f"{order.order_type.value.upper()} Order Failed - Manual Action Required",
        message=(
            f"Order {str(order.id)[:8]} for {order.token_symbol} failed after "
            f"{order.attempt_count} attempts.\n\n"
            f"Error: {order.last_error}\n\n"
            f"Action needed: Review and either retry manually or cancel."
        ),
        data={
            "order_id": str(order.id),
            "order_type": order.order_type.value,
            "token": order.token_address,
            "token_symbol": order.token_symbol,
            "position_id": order.position_id,
            "attempts": order.attempt_count,
            "error": order.last_error,
        },
        requires_action=True,
        dedupe_key=f"order_failed_{order.id}",
    )
```

### Alert Resolution on Order Completion

**src/walltrack/services/order/executor.py (modification):**
```python
async def _resolve_order_alert(self, order: Order, resolution: str) -> None:
    """Resolve any existing alert for this order."""
    from walltrack.services.alerts.alert_service import get_alert_service

    alert_service = await get_alert_service()
    await alert_service.resolve_by_dedupe_key(
        dedupe_key=f"order_failed_{order.id}",
        resolution=resolution
    )
```

### Gradio Alert Panel

**src/walltrack/ui/components/alerts_panel.py:**
```python
"""Alerts panel for dashboard."""

import gradio as gr
from datetime import datetime


def create_alerts_panel():
    """Create alerts panel with badge and list."""

    with gr.Column() as alerts_panel:
        # Header with badge
        with gr.Row():
            gr.Markdown("### Alerts")
            alert_badge = gr.Textbox(
                label="",
                value="0",
                interactive=False,
                elem_classes=["alert-badge"]
            )

        # Filter
        severity_filter = gr.Dropdown(
            choices=["All", "critical", "high", "warning", "info"],
            value="All",
            label="Severity"
        )

        # Alerts list
        alerts_table = gr.Dataframe(
            headers=["ID", "Severity", "Title", "Age", "Status"],
            datatype=["str", "str", "str", "str", "str"],
            label="Active Alerts",
            interactive=False,
        )

        # Selected alert detail
        with gr.Accordion("Alert Details", open=False) as alert_detail:
            alert_id = gr.Textbox(label="Alert ID", interactive=False)
            alert_title = gr.Textbox(label="Title", interactive=False)
            alert_message = gr.Textbox(label="Message", lines=4, interactive=False)
            alert_data = gr.JSON(label="Context Data")

            with gr.Row():
                acknowledge_btn = gr.Button("Acknowledge", variant="secondary")
                resolve_btn = gr.Button("Resolve", variant="primary")
                view_order_btn = gr.Button("View Order", visible=False)

            resolution_input = gr.Textbox(
                label="Resolution Notes",
                placeholder="How was this resolved?",
                visible=False
            )

    return alerts_panel, {
        "alert_badge": alert_badge,
        "severity_filter": severity_filter,
        "alerts_table": alerts_table,
        "alert_id": alert_id,
        "alert_title": alert_title,
        "alert_message": alert_message,
        "alert_data": alert_data,
        "acknowledge_btn": acknowledge_btn,
        "resolve_btn": resolve_btn,
        "view_order_btn": view_order_btn,
        "resolution_input": resolution_input,
    }


async def load_alerts(severity_filter: str = "All"):
    """Load active alerts."""
    from walltrack.services.alerts.alert_service import get_alert_service

    alert_service = await get_alert_service()

    severity = severity_filter if severity_filter != "All" else None
    alerts = await alert_service.get_active_alerts(severity=severity)

    rows = []
    for alert in alerts:
        age = _format_age(alert.created_at)
        status = "!" if alert.requires_action else alert.status.value
        rows.append([
            str(alert.id)[:8],
            alert.severity.value.upper(),
            alert.title,
            age,
            status,
        ])

    # Get counts for badge
    counts = await alert_service.get_active_count()
    badge = f"{counts['critical']}" if counts['critical'] > 0 else f"{counts['total']}"

    return rows, badge


async def acknowledge_alert_action(alert_id: str):
    """Acknowledge an alert."""
    from walltrack.services.alerts.alert_service import get_alert_service

    if not alert_id:
        return "No alert selected"

    alert_service = await get_alert_service()
    success = await alert_service.acknowledge_alert(alert_id)

    return "Acknowledged" if success else "Failed to acknowledge"


async def resolve_alert_action(alert_id: str, resolution: str):
    """Resolve an alert."""
    from walltrack.services.alerts.alert_service import get_alert_service

    if not alert_id:
        return "No alert selected"

    if not resolution:
        return "Please provide resolution notes"

    alert_service = await get_alert_service()
    success = await alert_service.resolve_alert(alert_id, resolution)

    return "Resolved" if success else "Failed to resolve"


def _format_age(created_at: datetime) -> str:
    """Format age for display."""
    age_hours = (datetime.utcnow() - created_at).total_seconds() / 3600

    if age_hours < 1:
        minutes = int(age_hours * 60)
        return f"{minutes}m ago"
    elif age_hours < 24:
        return f"{int(age_hours)}h ago"
    else:
        days = int(age_hours / 24)
        return f"{days}d ago"
```

## Implementation Tasks

- [ ] Create Alert model
- [ ] Create AlertService class
- [ ] Implement deduplication logic
- [ ] Create alerts migration
- [ ] Integrate with RetryWorker
- [ ] Add alert resolution on order completion
- [ ] Create Gradio alerts_panel
- [ ] Add badge with critical count
- [ ] Implement acknowledge/resolve actions
- [ ] Add notification event emission
- [ ] Write unit tests
- [ ] Write integration tests

## Definition of Done

- [ ] Alerts created on permanent order failure
- [ ] EXIT failures are CRITICAL severity
- [ ] Deduplication prevents duplicates
- [ ] Alerts resolved when order completes
- [ ] Gradio shows active alerts with badge
- [ ] Can acknowledge and resolve from UI
- [ ] Full test coverage

## File List

### New Files
- `src/walltrack/models/alert.py` - Alert model
- `src/walltrack/services/alerts/alert_service.py` - Alert service
- `src/walltrack/ui/components/alerts_panel.py` - Alerts panel
- `migrations/V12__alerts.sql` - Alerts table
- `tests/unit/services/alerts/test_alert_service.py` - Tests

### Modified Files
- `src/walltrack/services/order/retry_worker.py` - Create alerts
- `src/walltrack/services/order/executor.py` - Resolve alerts
- `src/walltrack/ui/pages/dashboard.py` - Add alerts panel
