# Story 10.5.1: Order Model & State Machine

## Story Info
- **Epic**: Epic 10.5 - Order Management, Price Oracle & Risk-Based Sizing
- **Status**: ready
- **Priority**: P0 - Critical
- **Story Points**: 5
- **Depends on**: None (fondation)

## User Story

**As a** system architect,
**I want** un modèle Order avec états et transitions validées,
**So that** chaque trade est tracé de la demande à l'exécution avec retry automatique.

## Acceptance Criteria

### AC 1: Order Model Creation
**Given** un signal validé arrive
**When** le système crée un Order
**Then** l'Order a un ID unique (UUID)
**And** contient: type (ENTRY/EXIT), side (BUY/SELL), token_address
**And** contient: amount_sol, expected_price, max_slippage_bps
**And** status initial = PENDING

### AC 2: State Machine Transitions
**Given** un Order existe
**When** une transition d'état est demandée
**Then** seules les transitions valides sont acceptées:
```
PENDING → SUBMITTED (order envoyé à Jupiter)
SUBMITTED → CONFIRMING (tx envoyée, attente confirmation)
CONFIRMING → FILLED (tx confirmée)
CONFIRMING → FAILED (tx échouée/timeout)
SUBMITTED → FAILED (erreur API)
FAILED → PENDING (retry automatique si attempts < max)
PENDING → CANCELLED (annulation manuelle ou max retries)
```
**And** les transitions invalides lèvent une exception

### AC 3: Retry Metadata
**Given** un Order échoue
**When** le retry est planifié
**Then** attempt_count est incrémenté
**And** last_error contient le message d'erreur
**And** next_retry_at est calculé (backoff exponentiel: 5s, 15s, 45s)

### AC 4: Order Completion
**Given** un Order est FILLED
**When** les données de confirmation arrivent
**Then** actual_price est enregistré
**And** tx_signature est stocké
**And** filled_at timestamp est set
**And** slippage réel est calculé

### AC 5: Simulation Mode Support
**Given** le système est en mode simulation
**When** un Order est créé
**Then** is_simulated = True
**And** le flow est identique mais sans tx réelle

## Technical Specifications

### Order Model

**src/walltrack/models/order.py:**
```python
"""Order model with state machine."""

from datetime import datetime, timedelta
from decimal import Decimal
from enum import Enum
from typing import Optional
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, computed_field


class OrderType(str, Enum):
    """Type of order."""
    ENTRY = "entry"
    EXIT = "exit"


class OrderSide(str, Enum):
    """Order side."""
    BUY = "buy"
    SELL = "sell"


class OrderStatus(str, Enum):
    """Order status with valid transitions."""
    PENDING = "pending"          # Waiting to be submitted
    SUBMITTED = "submitted"      # Sent to Jupiter API
    CONFIRMING = "confirming"    # TX sent, waiting for confirmation
    FILLED = "filled"            # Successfully executed
    FAILED = "failed"            # Execution failed (may retry)
    CANCELLED = "cancelled"      # Permanently cancelled


# Valid state transitions
ORDER_TRANSITIONS: dict[OrderStatus, list[OrderStatus]] = {
    OrderStatus.PENDING: [OrderStatus.SUBMITTED, OrderStatus.CANCELLED],
    OrderStatus.SUBMITTED: [OrderStatus.CONFIRMING, OrderStatus.FAILED],
    OrderStatus.CONFIRMING: [OrderStatus.FILLED, OrderStatus.FAILED],
    OrderStatus.FAILED: [OrderStatus.PENDING, OrderStatus.CANCELLED],
    OrderStatus.FILLED: [],  # Terminal state
    OrderStatus.CANCELLED: [],  # Terminal state
}

# Retry backoff delays (seconds)
RETRY_DELAYS = [5, 15, 45]  # Exponential backoff


class OrderTransitionError(Exception):
    """Invalid order state transition."""
    pass


class Order(BaseModel):
    """
    Order model representing a trade request.

    Tracks the full lifecycle from creation to execution.
    """
    id: UUID = Field(default_factory=uuid4)

    # Type and direction
    order_type: OrderType
    side: OrderSide

    # References
    signal_id: Optional[str] = None  # For ENTRY orders
    position_id: Optional[str] = None  # For EXIT orders

    # Token info
    token_address: str
    token_symbol: Optional[str] = None

    # Amounts
    amount_sol: Decimal
    amount_tokens: Optional[Decimal] = None  # Filled after execution

    # Pricing
    expected_price: Decimal
    actual_price: Optional[Decimal] = None
    max_slippage_bps: int = 100  # 1% default

    # Status
    status: OrderStatus = OrderStatus.PENDING

    # Execution details
    tx_signature: Optional[str] = None
    filled_at: Optional[datetime] = None

    # Retry management
    attempt_count: int = 0
    max_attempts: int = 3
    last_error: Optional[str] = None
    next_retry_at: Optional[datetime] = None

    # Simulation
    is_simulated: bool = False

    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    @computed_field
    @property
    def slippage_bps(self) -> Optional[int]:
        """Calculate actual slippage in basis points."""
        if self.actual_price is None or self.expected_price == 0:
            return None
        diff = abs(self.actual_price - self.expected_price) / self.expected_price
        return int(diff * 10000)

    @computed_field
    @property
    def can_retry(self) -> bool:
        """Check if order can be retried."""
        return (
            self.status == OrderStatus.FAILED
            and self.attempt_count < self.max_attempts
        )

    @computed_field
    @property
    def is_terminal(self) -> bool:
        """Check if order is in terminal state."""
        return self.status in [OrderStatus.FILLED, OrderStatus.CANCELLED]

    def transition_to(self, new_status: OrderStatus) -> None:
        """
        Transition to new status with validation.

        Raises:
            OrderTransitionError: If transition is invalid
        """
        valid_next = ORDER_TRANSITIONS.get(self.status, [])

        if new_status not in valid_next:
            raise OrderTransitionError(
                f"Invalid transition: {self.status.value} -> {new_status.value}. "
                f"Valid transitions: {[s.value for s in valid_next]}"
            )

        self.status = new_status
        self.updated_at = datetime.utcnow()

    def mark_submitted(self) -> None:
        """Mark order as submitted to Jupiter."""
        self.transition_to(OrderStatus.SUBMITTED)

    def mark_confirming(self, tx_signature: str) -> None:
        """Mark order as confirming with TX signature."""
        self.tx_signature = tx_signature
        self.transition_to(OrderStatus.CONFIRMING)

    def mark_filled(
        self,
        actual_price: Decimal,
        amount_tokens: Optional[Decimal] = None
    ) -> None:
        """Mark order as successfully filled."""
        self.actual_price = actual_price
        self.amount_tokens = amount_tokens
        self.filled_at = datetime.utcnow()
        self.transition_to(OrderStatus.FILLED)

    def mark_failed(self, error: str) -> None:
        """Mark order as failed and schedule retry if possible."""
        self.last_error = error
        self.attempt_count += 1
        self.transition_to(OrderStatus.FAILED)

        if self.can_retry:
            delay_index = min(self.attempt_count - 1, len(RETRY_DELAYS) - 1)
            delay = RETRY_DELAYS[delay_index]
            self.next_retry_at = datetime.utcnow() + timedelta(seconds=delay)

    def schedule_retry(self) -> None:
        """Move failed order back to pending for retry."""
        if not self.can_retry:
            raise OrderTransitionError(
                f"Cannot retry: attempts={self.attempt_count}/{self.max_attempts}"
            )
        self.transition_to(OrderStatus.PENDING)
        self.next_retry_at = None

    def cancel(self, reason: str = "Manually cancelled") -> None:
        """Cancel the order permanently."""
        self.last_error = reason
        self.transition_to(OrderStatus.CANCELLED)


class OrderCreateRequest(BaseModel):
    """Request to create a new order."""
    order_type: OrderType
    side: OrderSide
    token_address: str
    token_symbol: Optional[str] = None
    amount_sol: Decimal
    expected_price: Decimal
    max_slippage_bps: int = 100
    signal_id: Optional[str] = None
    position_id: Optional[str] = None
    is_simulated: bool = False


class OrderSummary(BaseModel):
    """Summary view of an order for UI."""
    id: UUID
    order_type: OrderType
    side: OrderSide
    token_symbol: Optional[str]
    amount_sol: Decimal
    status: OrderStatus
    attempt_count: int
    is_simulated: bool
    created_at: datetime
    slippage_bps: Optional[int] = None
```

### Order Factory

**src/walltrack/services/order/order_factory.py:**
```python
"""Factory for creating orders."""

from decimal import Decimal
from typing import Optional

from walltrack.models.order import (
    Order,
    OrderType,
    OrderSide,
    OrderCreateRequest,
)
from walltrack.models.signal import Signal
from walltrack.models.position import Position


class OrderFactory:
    """Factory for creating Order instances."""

    def __init__(self, is_simulation_mode: bool = False):
        self.is_simulation_mode = is_simulation_mode

    def create_entry_order(
        self,
        signal: Signal,
        amount_sol: Decimal,
        expected_price: Decimal,
        max_slippage_bps: int = 100,
    ) -> Order:
        """Create an entry order from a signal."""
        return Order(
            order_type=OrderType.ENTRY,
            side=OrderSide.BUY,
            signal_id=signal.id,
            token_address=signal.token_address,
            token_symbol=signal.token_symbol,
            amount_sol=amount_sol,
            expected_price=expected_price,
            max_slippage_bps=max_slippage_bps,
            is_simulated=self.is_simulation_mode,
        )

    def create_exit_order(
        self,
        position: Position,
        amount_tokens: Decimal,
        expected_price: Decimal,
        exit_reason: str,
        max_slippage_bps: int = 100,
    ) -> Order:
        """Create an exit order for a position."""
        # Calculate SOL equivalent
        amount_sol = amount_tokens * expected_price

        return Order(
            order_type=OrderType.EXIT,
            side=OrderSide.SELL,
            position_id=str(position.id),
            token_address=position.token_address,
            token_symbol=position.token_symbol,
            amount_sol=amount_sol,
            amount_tokens=amount_tokens,
            expected_price=expected_price,
            max_slippage_bps=max_slippage_bps,
            is_simulated=self.is_simulation_mode,
        )

    def from_request(self, request: OrderCreateRequest) -> Order:
        """Create order from API request."""
        return Order(
            order_type=request.order_type,
            side=request.side,
            token_address=request.token_address,
            token_symbol=request.token_symbol,
            amount_sol=request.amount_sol,
            expected_price=request.expected_price,
            max_slippage_bps=request.max_slippage_bps,
            signal_id=request.signal_id,
            position_id=request.position_id,
            is_simulated=request.is_simulated or self.is_simulation_mode,
        )
```

## Implementation Tasks

- [ ] Create `src/walltrack/models/order.py` with Order model
- [ ] Implement OrderStatus enum with all states
- [ ] Implement state machine with transition validation
- [ ] Create OrderTransitionError exception
- [ ] Implement retry logic with exponential backoff
- [ ] Create OrderFactory for order creation
- [ ] Create OrderCreateRequest/OrderSummary DTOs
- [ ] Write unit tests for state transitions
- [ ] Write unit tests for retry logic
- [ ] Add exports to `__init__.py`

## Definition of Done

- [ ] Order model handles all states correctly
- [ ] Invalid state transitions raise exception
- [ ] Retry backoff is calculated correctly
- [ ] Factory creates orders from signals and positions
- [ ] Simulation mode flag is preserved
- [ ] 100% test coverage on state machine

## Test Cases

```python
# tests/unit/models/test_order.py

import pytest
from datetime import datetime, timedelta
from decimal import Decimal

from walltrack.models.order import (
    Order, OrderType, OrderSide, OrderStatus,
    OrderTransitionError, RETRY_DELAYS
)


class TestOrderStateMachine:
    """Test order state transitions."""

    def test_pending_to_submitted(self):
        """PENDING -> SUBMITTED is valid."""
        order = Order(
            order_type=OrderType.ENTRY,
            side=OrderSide.BUY,
            token_address="token123",
            amount_sol=Decimal("1.0"),
            expected_price=Decimal("0.001"),
        )
        order.mark_submitted()
        assert order.status == OrderStatus.SUBMITTED

    def test_pending_to_filled_invalid(self):
        """PENDING -> FILLED is invalid."""
        order = Order(
            order_type=OrderType.ENTRY,
            side=OrderSide.BUY,
            token_address="token123",
            amount_sol=Decimal("1.0"),
            expected_price=Decimal("0.001"),
        )
        with pytest.raises(OrderTransitionError):
            order.mark_filled(Decimal("0.001"))

    def test_submitted_to_confirming(self):
        """SUBMITTED -> CONFIRMING with TX signature."""
        order = Order(
            order_type=OrderType.ENTRY,
            side=OrderSide.BUY,
            token_address="token123",
            amount_sol=Decimal("1.0"),
            expected_price=Decimal("0.001"),
            status=OrderStatus.SUBMITTED,
        )
        order.mark_confirming("tx_sig_123")
        assert order.status == OrderStatus.CONFIRMING
        assert order.tx_signature == "tx_sig_123"

    def test_confirming_to_filled(self):
        """CONFIRMING -> FILLED with price."""
        order = Order(
            order_type=OrderType.ENTRY,
            side=OrderSide.BUY,
            token_address="token123",
            amount_sol=Decimal("1.0"),
            expected_price=Decimal("0.001"),
            status=OrderStatus.CONFIRMING,
            tx_signature="tx_sig_123",
        )
        order.mark_filled(Decimal("0.00105"), Decimal("950"))
        assert order.status == OrderStatus.FILLED
        assert order.actual_price == Decimal("0.00105")
        assert order.filled_at is not None


class TestOrderRetry:
    """Test retry logic."""

    def test_failed_can_retry(self):
        """Failed order with attempts left can retry."""
        order = Order(
            order_type=OrderType.ENTRY,
            side=OrderSide.BUY,
            token_address="token123",
            amount_sol=Decimal("1.0"),
            expected_price=Decimal("0.001"),
            status=OrderStatus.SUBMITTED,
        )
        order.mark_failed("API error")

        assert order.status == OrderStatus.FAILED
        assert order.can_retry is True
        assert order.attempt_count == 1
        assert order.next_retry_at is not None

    def test_retry_backoff_exponential(self):
        """Retry delays increase exponentially."""
        order = Order(
            order_type=OrderType.ENTRY,
            side=OrderSide.BUY,
            token_address="token123",
            amount_sol=Decimal("1.0"),
            expected_price=Decimal("0.001"),
            status=OrderStatus.SUBMITTED,
        )

        # First failure: 5s delay
        order.mark_failed("Error 1")
        delay1 = (order.next_retry_at - datetime.utcnow()).total_seconds()
        assert 4 < delay1 < 6

        # Reset for second attempt
        order.schedule_retry()
        order.mark_submitted()
        order.mark_failed("Error 2")
        delay2 = (order.next_retry_at - datetime.utcnow()).total_seconds()
        assert 14 < delay2 < 16

    def test_max_retries_exhausted(self):
        """Order cannot retry after max attempts."""
        order = Order(
            order_type=OrderType.ENTRY,
            side=OrderSide.BUY,
            token_address="token123",
            amount_sol=Decimal("1.0"),
            expected_price=Decimal("0.001"),
            attempt_count=3,
            max_attempts=3,
            status=OrderStatus.FAILED,
        )
        assert order.can_retry is False


class TestOrderSlippage:
    """Test slippage calculation."""

    def test_slippage_calculation(self):
        """Slippage calculated correctly."""
        order = Order(
            order_type=OrderType.ENTRY,
            side=OrderSide.BUY,
            token_address="token123",
            amount_sol=Decimal("1.0"),
            expected_price=Decimal("0.001"),
            actual_price=Decimal("0.00105"),  # 5% slippage
            status=OrderStatus.FILLED,
        )
        assert order.slippage_bps == 500  # 5%
```

## File List

### New Files
- `src/walltrack/models/order.py` - Order model, OrderStatus, OrderType, OrderSide, transitions
- `src/walltrack/services/order/__init__.py` - Package init
- `src/walltrack/services/order/order_factory.py` - OrderFactory class
- `tests/unit/models/test_order.py` - Order model tests
- `tests/unit/services/order/test_order_factory.py` - Factory tests

### Modified Files
- `src/walltrack/models/__init__.py` - Export Order, OrderType, OrderSide, OrderStatus
