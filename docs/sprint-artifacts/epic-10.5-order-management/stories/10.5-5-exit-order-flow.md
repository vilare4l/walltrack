# Story 10.5.5: Exit Order Flow

## Story Info
- **Epic**: Epic 10.5 - Order Management, Price Oracle & Risk-Based Sizing
- **Status**: ready
- **Priority**: P0 - Critical
- **Story Points**: 5
- **Depends on**: Story 10.5.4 (Entry Order Flow)

## User Story

**As a** exit manager,
**I want** créer un Order de sortie au lieu d'exécuter directement,
**So that** les exits ont aussi le retry logic et l'historique complet.

## Acceptance Criteria

### AC 1: Exit Trigger to Order
**Given** une condition de sortie est atteinte (SL, TP, trailing, time)
**When** l'ExitManager déclenche une sortie
**Then** un Order EXIT est créé (pas d'exécution directe)
**And** l'Order contient position_id, amount_tokens, exit_reason
**And** status initial = PENDING

### AC 2: Partial Exit Support
**Given** un TP partiel est atteint (ex: TP1 = 33%)
**When** l'Order EXIT est créé
**Then** amount_tokens = position.remaining_tokens * tp_sell_pct / 100
**And** la position reste ouverte avec le solde restant
**And** position.realized_pnl est mis à jour

### AC 3: Full Exit on Stop Loss
**Given** le stop loss est atteint
**When** l'Order EXIT est créé
**Then** amount_tokens = position.remaining_tokens (100%)
**And** quand FILLED, position.status = CLOSED

### AC 4: Exit Retry on Failure
**Given** un Order EXIT échoue
**When** les retries sont tentés
**Then** la position reste "exit_pending"
**And** les retries continuent jusqu'à max_attempts
**And** si CANCELLED, alerte critique + action manuelle requise

### AC 5: Priority for Exit Orders
**Given** plusieurs ordres sont en attente
**When** le système traite les ordres
**Then** les EXIT orders ont priorité sur les ENTRY orders
**And** les SL exits ont priorité sur les TP exits

## Technical Specifications

### Exit Order Service

**src/walltrack/services/order/exit_service.py:**
```python
"""Service for creating and managing exit orders."""

from decimal import Decimal
from enum import Enum
from typing import Optional
from datetime import datetime

import structlog

from walltrack.models.order import Order, OrderType, OrderSide, OrderStatus
from walltrack.models.position import Position, PositionStatus
from walltrack.data.supabase.repositories.order_repo import OrderRepository
from walltrack.data.supabase.repositories.position_repo import PositionRepository
from walltrack.services.order.executor import OrderExecutor, get_order_executor
from walltrack.services.order.order_factory import OrderFactory
from walltrack.services.pricing.price_oracle import PriceOracle, get_price_oracle

logger = structlog.get_logger(__name__)


class ExitReason(str, Enum):
    """Reason for exit."""
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT_1 = "take_profit_1"
    TAKE_PROFIT_2 = "take_profit_2"
    TAKE_PROFIT_3 = "take_profit_3"
    TRAILING_STOP = "trailing_stop"
    TIME_LIMIT = "time_limit"
    STAGNATION = "stagnation"
    MANUAL = "manual"
    EMERGENCY = "emergency"


class ExitOrderService:
    """
    Service for handling exit order flow.

    Creates exit orders and updates positions on fill.
    """

    def __init__(
        self,
        order_repo: OrderRepository,
        position_repo: PositionRepository,
        executor: OrderExecutor,
        price_oracle: PriceOracle,
        order_factory: OrderFactory,
    ):
        self.order_repo = order_repo
        self.position_repo = position_repo
        self.executor = executor
        self.price_oracle = price_oracle
        self.order_factory = order_factory

    async def create_exit_order(
        self,
        position: Position,
        exit_reason: ExitReason,
        sell_percent: Decimal = Decimal("100"),
        max_slippage_bps: int = 150,  # Higher slippage for exits
    ) -> Optional[Order]:
        """
        Create an exit order for a position.

        Args:
            position: The position to exit
            exit_reason: Why we're exiting
            sell_percent: Percentage of remaining tokens to sell (1-100)
            max_slippage_bps: Maximum slippage allowed

        Returns:
            Created order or None if position can't be exited
        """
        log = logger.bind(
            position_id=str(position.id),
            reason=exit_reason.value,
            sell_pct=str(sell_percent)
        )

        # Validate position can be exited
        if position.status not in [PositionStatus.OPEN, PositionStatus.PARTIAL_EXIT]:
            log.warning("position_not_exitable", status=position.status.value)
            return None

        # Check for pending exit orders
        pending_exits = await self.order_repo.get_by_position(
            position.id,
            order_type=OrderType.EXIT
        )
        active_exits = [o for o in pending_exits if not o.is_terminal]

        if active_exits:
            log.warning("exit_already_pending", count=len(active_exits))
            return None

        # Get current price
        price_result = await self.price_oracle.get_price(position.token_address)
        if not price_result.success:
            log.error("price_fetch_failed", error=price_result.error)
            # For SL exits, use last known price as fallback
            if exit_reason == ExitReason.STOP_LOSS:
                expected_price = position.current_price or position.entry_price * Decimal("0.5")
            else:
                return None
        else:
            expected_price = price_result.price

        # Calculate amount to sell
        remaining_tokens = position.entry_amount_tokens - position.sold_tokens
        amount_tokens = remaining_tokens * sell_percent / Decimal("100")

        # Create exit order
        order = self.order_factory.create_exit_order(
            position=position,
            amount_tokens=amount_tokens,
            expected_price=expected_price,
            exit_reason=exit_reason.value,
            max_slippage_bps=max_slippage_bps,
        )

        await self.order_repo.create(order)
        log.info("exit_order_created", order_id=str(order.id), amount=str(amount_tokens))

        # Mark position as exit pending
        position.status = PositionStatus.EXIT_PENDING
        position.exit_reason = exit_reason.value
        await self.position_repo.update(position)

        return order

    async def execute_exit_order(self, order: Order) -> bool:
        """
        Execute an exit order and update position.

        Returns:
            True if exit was successful
        """
        log = logger.bind(order_id=str(order.id), position_id=order.position_id)

        result = await self.executor.execute(order)

        if result.success:
            await self._process_successful_exit(order)
            log.info("exit_executed", actual_price=str(result.actual_price))
            return True
        else:
            if order.can_retry:
                log.warning("exit_failed_will_retry", attempt=order.attempt_count)
            else:
                log.error("exit_failed_permanently", error=result.error)
                await self._create_critical_alert(order)
            return False

    async def _process_successful_exit(self, order: Order) -> None:
        """Update position after successful exit."""
        position = await self.position_repo.get_by_id(order.position_id)

        if not position:
            logger.error("position_not_found", position_id=order.position_id)
            return

        # Calculate PnL for this exit
        exit_value_sol = order.amount_tokens * order.actual_price
        entry_cost_ratio = order.amount_tokens / position.entry_amount_tokens
        entry_cost_sol = position.entry_amount_sol * entry_cost_ratio

        pnl_sol = exit_value_sol - entry_cost_sol

        # Update position
        position.sold_tokens += order.amount_tokens
        position.realized_pnl += pnl_sol
        position.last_exit_order_id = str(order.id)
        position.last_exit_price = order.actual_price
        position.last_exit_timestamp = order.filled_at

        # Check if fully exited
        remaining = position.entry_amount_tokens - position.sold_tokens

        if remaining <= Decimal("0.001"):  # Small threshold for rounding
            position.status = PositionStatus.CLOSED
            position.closed_at = datetime.utcnow()
            position.final_pnl = position.realized_pnl
        else:
            position.status = PositionStatus.PARTIAL_EXIT

        await self.position_repo.update(position)

    async def _create_critical_alert(self, order: Order) -> None:
        """Create critical alert for failed exit."""
        from walltrack.services.alerts.alert_service import get_alert_service

        alert_service = await get_alert_service()
        await alert_service.create_alert(
            alert_type="exit_failed_critical",
            severity="critical",
            title=f"EXIT FAILED - Manual action required",
            message=(
                f"Exit order {order.id} for position {order.position_id} "
                f"failed after {order.attempt_count} attempts. "
                f"Token: {order.token_symbol}. Error: {order.last_error}"
            ),
            data={
                "order_id": str(order.id),
                "position_id": order.position_id,
                "token": order.token_address,
                "error": order.last_error,
            },
            requires_action=True,
        )

    async def retry_failed_exit(self, order_id: str) -> bool:
        """Manually retry a failed exit order."""
        order = await self.order_repo.get_by_id(order_id)

        if not order:
            return False

        if order.status != OrderStatus.CANCELLED:
            return False

        # Create new exit order with same parameters
        position = await self.position_repo.get_by_id(order.position_id)

        new_order = await self.create_exit_order(
            position=position,
            exit_reason=ExitReason(order.exit_reason),
            sell_percent=Decimal("100"),  # Full remaining
            max_slippage_bps=200,  # Higher slippage for retry
        )

        if new_order:
            return await self.execute_exit_order(new_order)

        return False


# Singleton
_exit_service: Optional[ExitOrderService] = None


async def get_exit_order_service() -> ExitOrderService:
    """Get or create exit order service."""
    global _exit_service

    if _exit_service is None:
        from walltrack.core.config import get_settings

        settings = get_settings()

        _exit_service = ExitOrderService(
            order_repo=OrderRepository(),
            position_repo=PositionRepository(),
            executor=await get_order_executor(),
            price_oracle=await get_price_oracle(),
            order_factory=OrderFactory(is_simulation_mode=settings.simulation_mode),
        )

    return _exit_service
```

### ExitManager Integration

**src/walltrack/services/execution/exit_manager.py (modification):**
```python
"""Exit manager with order flow integration."""

# Remplacer l'exécution directe par la création d'ordres:

async def _execute_exit(
    self,
    position: Position,
    reason: str,
    sell_percent: Decimal
) -> bool:
    """Execute exit via order flow."""
    from walltrack.services.order.exit_service import (
        get_exit_order_service,
        ExitReason
    )

    exit_service = await get_exit_order_service()

    # Map reason string to ExitReason enum
    exit_reason = ExitReason(reason)

    order = await exit_service.create_exit_order(
        position=position,
        exit_reason=exit_reason,
        sell_percent=sell_percent,
    )

    if order is None:
        return False

    return await exit_service.execute_exit_order(order)
```

## Gradio UI Updates

### Position Exit Actions

**src/walltrack/ui/components/position_actions.py:**
```python
"""Position action buttons with order creation."""

import gradio as gr
from decimal import Decimal


def create_position_exit_controls():
    """Create exit controls for a position."""

    with gr.Column() as exit_controls:
        gr.Markdown("### Exit Actions")

        with gr.Row():
            exit_pct = gr.Slider(
                minimum=10,
                maximum=100,
                value=100,
                step=10,
                label="Exit Percentage"
            )

        with gr.Row():
            manual_exit_btn = gr.Button("Manual Exit", variant="primary")
            emergency_exit_btn = gr.Button("Emergency Exit", variant="stop")

        # Status for pending exits
        with gr.Row():
            exit_status = gr.Textbox(
                label="Exit Order Status",
                interactive=False,
                visible=False
            )
            retry_exit_btn = gr.Button("Retry Exit", visible=False)

    return exit_controls, {
        "exit_pct": exit_pct,
        "manual_exit_btn": manual_exit_btn,
        "emergency_exit_btn": emergency_exit_btn,
        "exit_status": exit_status,
        "retry_exit_btn": retry_exit_btn,
    }


async def handle_manual_exit(position_id: str, exit_pct: int):
    """Handle manual exit button click."""
    from walltrack.services.order.exit_service import (
        get_exit_order_service,
        ExitReason
    )
    from walltrack.data.supabase.repositories.position_repo import PositionRepository

    position_repo = PositionRepository()
    position = await position_repo.get_by_id(position_id)

    exit_service = await get_exit_order_service()
    order = await exit_service.create_exit_order(
        position=position,
        exit_reason=ExitReason.MANUAL,
        sell_percent=Decimal(str(exit_pct)),
    )

    if order:
        await exit_service.execute_exit_order(order)
        return f"Exit order created: {order.status.value}"
    else:
        return "Failed to create exit order"
```

## Implementation Tasks

- [ ] Create ExitOrderService class
- [ ] Implement create_exit_order with partial exit support
- [ ] Implement execute_exit_order with position update
- [ ] Calculate PnL on each exit
- [ ] Create critical alerts for failed exits
- [ ] Implement retry_failed_exit for manual recovery
- [ ] Modify ExitManager to use order flow
- [ ] Add priority queue for exit orders (Story 10.5.15)
- [ ] Add Gradio exit controls with order status
- [ ] Write unit tests
- [ ] Write integration tests

## Definition of Done

- [ ] All exits go through order flow
- [ ] Partial exits update position correctly
- [ ] Full exits close position
- [ ] Failed exits create critical alerts
- [ ] Manual retry works from UI
- [ ] PnL calculated correctly on each exit
- [ ] Full test coverage

## File List

### New Files
- `src/walltrack/services/order/exit_service.py` - ExitOrderService
- `src/walltrack/ui/components/position_actions.py` - Exit action controls
- `tests/unit/services/order/test_exit_service.py` - Exit service tests

### Modified Files
- `src/walltrack/services/execution/exit_manager.py` - Use order flow
- `src/walltrack/ui/pages/positions.py` - Add exit controls
