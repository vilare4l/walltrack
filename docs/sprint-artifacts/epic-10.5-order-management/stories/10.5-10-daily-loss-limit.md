# Story 10.5.10: Daily Loss Limit

## Story Info
- **Epic**: Epic 10.5 - Order Management, Price Oracle & Risk-Based Sizing
- **Status**: ready
- **Priority**: P1 - High
- **Story Points**: 3
- **Depends on**: Story 10.5.9 (Drawdown Reduction)

## User Story

**As a** risk-conscious trader,
**I want** stopper le trading si la perte journalière dépasse un seuil,
**So that** une mauvaise journée ne détruit pas le capital.

## Acceptance Criteria

### AC 1: Daily Loss Tracking
**Given** des trades sont exécutés aujourd'hui
**When** je calcule la perte journalière
**Then** je sum tous les realized_pnl des positions fermées aujourd'hui
**And** j'ajoute les unrealized_pnl des positions ouvertes

### AC 2: Limit Enforcement
**Given** daily_loss_limit_pct = 5%
**And** capital de départ = 100 SOL
**When** la perte journalière atteint -5 SOL
**Then** toutes les entrées sont bloquées
**And** les exits restent possibles (important pour limiter les pertes)

### AC 3: Reset at Midnight
**Given** le trading était bloqué hier
**When** minuit UTC passe
**Then** le compteur de perte journalière reset à 0
**And** le trading reprend automatiquement

### AC 4: Warning Before Limit
**Given** daily_loss_limit_pct = 5%
**When** la perte atteint 4% (80% du limit)
**Then** un warning est affiché dans Gradio
**And** une alerte est créée

### AC 5: Gradio Display
**Given** je suis sur le dashboard
**When** je regarde le panel Daily P&L
**Then** je vois la perte/profit du jour
**And** la distance au daily limit
**And** un indicateur visuel (vert/jaune/rouge)

## Technical Specifications

### Daily Loss Calculator

**src/walltrack/services/risk/daily_loss_tracker.py:**
```python
"""Tracks daily P&L and enforces loss limits."""

from dataclasses import dataclass
from datetime import datetime, date, timezone
from decimal import Decimal
from typing import Optional

import structlog

from walltrack.services.config.config_service import ConfigService, get_config_service

logger = structlog.get_logger(__name__)


@dataclass
class DailyPnLMetrics:
    """Daily profit/loss metrics."""
    date: date
    realized_pnl: Decimal
    unrealized_pnl: Decimal
    total_pnl: Decimal
    starting_capital: Decimal
    pnl_percentage: Decimal

    # Limit tracking
    daily_limit_pct: Decimal
    limit_remaining_pct: Decimal
    is_limit_hit: bool
    is_warning_zone: bool

    @property
    def limit_usage_pct(self) -> Decimal:
        """Percentage of daily limit used."""
        if self.daily_limit_pct == 0:
            return Decimal("0")
        # Only count losses
        if self.total_pnl >= 0:
            return Decimal("0")
        return abs(self.pnl_percentage) / self.daily_limit_pct * 100


class DailyLossTracker:
    """
    Tracks daily P&L and enforces loss limits.

    Blocks new entries when daily loss limit is reached.
    """

    WARNING_THRESHOLD_PCT = Decimal("80")  # Warn at 80% of limit

    def __init__(
        self,
        config_service: ConfigService,
    ):
        self.config_service = config_service

    async def get_daily_metrics(self) -> DailyPnLMetrics:
        """Get current daily P&L metrics."""
        from walltrack.data.supabase.client import get_supabase_client

        client = await get_supabase_client()
        today = datetime.now(timezone.utc).date()
        today_start = datetime(today.year, today.month, today.day, tzinfo=timezone.utc)

        # Get config
        config = await self.config_service.get_trading_config()
        daily_limit_pct = Decimal(str(config.daily_loss_limit_pct))
        limit_enabled = config.daily_loss_limit_enabled

        # Get starting capital (from daily snapshot or portfolio)
        starting_capital = await self._get_starting_capital(client, today)

        # Get realized P&L (closed positions today)
        realized_pnl = await self._get_realized_pnl(client, today_start)

        # Get unrealized P&L (open positions)
        unrealized_pnl = await self._get_unrealized_pnl(client)

        total_pnl = realized_pnl + unrealized_pnl

        # Calculate percentages
        if starting_capital > 0:
            pnl_percentage = (total_pnl / starting_capital) * 100
        else:
            pnl_percentage = Decimal("0")

        # Check limits
        is_limit_hit = False
        is_warning_zone = False
        limit_remaining_pct = daily_limit_pct

        if limit_enabled and total_pnl < 0:
            loss_pct = abs(pnl_percentage)
            limit_remaining_pct = daily_limit_pct - loss_pct

            if loss_pct >= daily_limit_pct:
                is_limit_hit = True
            elif loss_pct >= daily_limit_pct * self.WARNING_THRESHOLD_PCT / 100:
                is_warning_zone = True

        metrics = DailyPnLMetrics(
            date=today,
            realized_pnl=realized_pnl,
            unrealized_pnl=unrealized_pnl,
            total_pnl=total_pnl,
            starting_capital=starting_capital,
            pnl_percentage=pnl_percentage,
            daily_limit_pct=daily_limit_pct if limit_enabled else Decimal("0"),
            limit_remaining_pct=max(Decimal("0"), limit_remaining_pct),
            is_limit_hit=is_limit_hit,
            is_warning_zone=is_warning_zone,
        )

        logger.debug(
            "daily_pnl_calculated",
            total_pnl=str(total_pnl),
            pnl_pct=str(pnl_percentage),
            limit_hit=is_limit_hit
        )

        return metrics

    async def is_entry_allowed(self) -> tuple[bool, Optional[str]]:
        """Check if new entries are allowed."""
        metrics = await self.get_daily_metrics()

        if metrics.is_limit_hit:
            reason = (
                f"Daily loss limit reached: {metrics.pnl_percentage:.2f}% "
                f"(limit: {metrics.daily_limit_pct}%)"
            )
            logger.warning("entry_blocked_daily_limit", reason=reason)
            return False, reason

        if metrics.is_warning_zone:
            logger.info(
                "daily_limit_warning",
                pnl_pct=str(metrics.pnl_percentage),
                limit=str(metrics.daily_limit_pct)
            )

        return True, None

    async def _get_starting_capital(self, client, today: date) -> Decimal:
        """Get capital at start of day."""
        # Try to get from daily snapshot
        result = await client.table("daily_snapshots") \
            .select("starting_capital") \
            .eq("date", today.isoformat()) \
            .single() \
            .execute()

        if result.data:
            return Decimal(str(result.data["starting_capital"]))

        # Fallback: get latest portfolio value from yesterday
        yesterday = today.isoformat()
        result = await client.table("portfolio_snapshots") \
            .select("total_value_sol") \
            .lt("timestamp", yesterday) \
            .order("timestamp", desc=True) \
            .limit(1) \
            .execute()

        if result.data:
            return Decimal(str(result.data[0]["total_value_sol"]))

        # Fallback: sum current positions entry values
        result = await client.table("positions") \
            .select("entry_amount_sol") \
            .execute()

        total = sum(
            Decimal(str(row["entry_amount_sol"]))
            for row in result.data
        )

        return total if total > 0 else Decimal("10")  # Minimum default

    async def _get_realized_pnl(self, client, today_start: datetime) -> Decimal:
        """Get realized P&L from positions closed today."""
        result = await client.table("positions") \
            .select("realized_pnl") \
            .eq("status", "closed") \
            .gte("closed_at", today_start.isoformat()) \
            .execute()

        return sum(
            Decimal(str(row.get("realized_pnl", 0) or 0))
            for row in result.data
        )

    async def _get_unrealized_pnl(self, client) -> Decimal:
        """Get unrealized P&L from open positions."""
        result = await client.table("positions") \
            .select("unrealized_pnl") \
            .in_("status", ["open", "partial_exit"]) \
            .execute()

        return sum(
            Decimal(str(row.get("unrealized_pnl", 0) or 0))
            for row in result.data
        )


# Singleton
_tracker: Optional[DailyLossTracker] = None


async def get_daily_loss_tracker() -> DailyLossTracker:
    """Get or create daily loss tracker."""
    global _tracker
    if _tracker is None:
        _tracker = DailyLossTracker(
            config_service=await get_config_service()
        )
    return _tracker
```

### Daily Snapshot Job

**src/walltrack/services/jobs/daily_snapshot.py:**
```python
"""Daily snapshot job for tracking starting capital."""

from datetime import datetime, timezone
from decimal import Decimal

import structlog

logger = structlog.get_logger(__name__)


async def create_daily_snapshot() -> None:
    """Create daily snapshot at midnight UTC."""
    from walltrack.data.supabase.client import get_supabase_client

    client = await get_supabase_client()
    today = datetime.now(timezone.utc).date()

    # Check if already exists
    existing = await client.table("daily_snapshots") \
        .select("id") \
        .eq("date", today.isoformat()) \
        .execute()

    if existing.data:
        logger.debug("daily_snapshot_exists", date=today.isoformat())
        return

    # Calculate starting capital
    # Get latest portfolio snapshot
    result = await client.table("portfolio_snapshots") \
        .select("total_value_sol") \
        .order("timestamp", desc=True) \
        .limit(1) \
        .execute()

    if result.data:
        starting_capital = Decimal(str(result.data[0]["total_value_sol"]))
    else:
        # Fallback
        starting_capital = Decimal("10")

    # Create snapshot
    await client.table("daily_snapshots").insert({
        "date": today.isoformat(),
        "starting_capital": str(starting_capital),
        "created_at": datetime.now(timezone.utc).isoformat(),
    }).execute()

    logger.info("daily_snapshot_created", date=today.isoformat(), capital=str(starting_capital))
```

### Database Migration

**migrations/V11__daily_snapshots.sql:**
```sql
-- Daily snapshots for tracking starting capital
CREATE TABLE IF NOT EXISTS walltrack.daily_snapshots (
    id BIGSERIAL PRIMARY KEY,
    date DATE NOT NULL UNIQUE,
    starting_capital DECIMAL(20, 8) NOT NULL,

    -- End of day values (updated by job)
    ending_capital DECIMAL(20, 8),
    realized_pnl DECIMAL(20, 8),
    unrealized_pnl DECIMAL(20, 8),
    trades_count INTEGER DEFAULT 0,
    wins INTEGER DEFAULT 0,
    losses INTEGER DEFAULT 0,

    -- Limits status
    daily_limit_hit BOOLEAN DEFAULT FALSE,
    daily_limit_hit_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_daily_snapshots_date ON walltrack.daily_snapshots(date DESC);
```

### Integration with Risk Manager

**src/walltrack/services/risk/risk_manager.py (modification):**
```python
# Dans check_entry_allowed, ajouter:

async def check_entry_allowed(
    self,
    token_address: str,
    cluster_id: Optional[str] = None,
) -> RiskCheckResult:
    """Check if entry is allowed by all risk rules."""

    # 1. Check daily loss limit
    from walltrack.services.risk.daily_loss_tracker import get_daily_loss_tracker

    daily_tracker = await get_daily_loss_tracker()
    daily_allowed, daily_reason = await daily_tracker.is_entry_allowed()

    if not daily_allowed:
        return RiskCheckResult(
            allowed=False,
            reason=daily_reason,
            rule_triggered="daily_loss_limit"
        )

    # 2. Check drawdown limit (via size reduction)
    from walltrack.services.risk.size_reduction import get_size_reduction_applicator

    reduction_applicator = await get_size_reduction_applicator()
    reduction = await reduction_applicator.apply_reduction(Decimal("1"))

    if reduction.trading_blocked:
        return RiskCheckResult(
            allowed=False,
            reason="Drawdown limit reached",
            rule_triggered="drawdown_limit"
        )

    # 3. Other checks (concentration, etc.)
    # ... existing code ...

    return RiskCheckResult(allowed=True)
```

### Gradio Daily P&L Component

**src/walltrack/ui/components/daily_pnl.py:**
```python
"""Daily P&L display with limit indicator."""

import gradio as gr
from decimal import Decimal


def create_daily_pnl_panel():
    """Create daily P&L panel for dashboard."""

    with gr.Column() as pnl_panel:
        gr.Markdown("### Daily P&L")

        with gr.Row():
            total_pnl = gr.Number(
                label="Total P&L (SOL)",
                precision=4,
                interactive=False
            )
            pnl_pct = gr.Number(
                label="P&L %",
                precision=2,
                interactive=False
            )

        with gr.Row():
            realized = gr.Number(
                label="Realized",
                precision=4,
                interactive=False
            )
            unrealized = gr.Number(
                label="Unrealized",
                precision=4,
                interactive=False
            )

        with gr.Row():
            limit_status = gr.Textbox(
                label="Daily Limit Status",
                interactive=False
            )
            limit_remaining = gr.Textbox(
                label="Limit Remaining",
                interactive=False
            )

        # Visual progress bar
        limit_usage = gr.Slider(
            minimum=0,
            maximum=100,
            value=0,
            label="Daily Limit Usage",
            interactive=False
        )

    return pnl_panel, {
        "total_pnl": total_pnl,
        "pnl_pct": pnl_pct,
        "realized": realized,
        "unrealized": unrealized,
        "limit_status": limit_status,
        "limit_remaining": limit_remaining,
        "limit_usage": limit_usage,
    }


async def update_daily_pnl():
    """Update daily P&L display."""
    from walltrack.services.risk.daily_loss_tracker import get_daily_loss_tracker

    tracker = await get_daily_loss_tracker()
    metrics = await tracker.get_daily_metrics()

    # Determine status text and color indicator
    if metrics.is_limit_hit:
        status = "LIMIT HIT - Entries blocked"
    elif metrics.is_warning_zone:
        status = "WARNING - Approaching limit"
    else:
        status = "OK"

    remaining_text = f"{metrics.limit_remaining_pct:.1f}%"

    return (
        float(metrics.total_pnl),
        float(metrics.pnl_percentage),
        float(metrics.realized_pnl),
        float(metrics.unrealized_pnl),
        status,
        remaining_text,
        float(metrics.limit_usage_pct),
    )
```

### Warning Alert on Approach

**src/walltrack/services/risk/daily_loss_tracker.py (addition):**
```python
async def check_and_alert(self) -> None:
    """Check daily limit and create alert if needed."""
    metrics = await self.get_daily_metrics()

    if metrics.is_limit_hit:
        await self._create_alert(
            severity="critical",
            title="Daily Loss Limit Hit",
            message=(
                f"Daily loss limit of {metrics.daily_limit_pct}% has been reached. "
                f"Current loss: {metrics.pnl_percentage:.2f}%. "
                f"New entries are blocked until tomorrow."
            )
        )

    elif metrics.is_warning_zone:
        await self._create_alert(
            severity="warning",
            title="Approaching Daily Loss Limit",
            message=(
                f"Daily loss at {abs(metrics.pnl_percentage):.2f}%, "
                f"approaching limit of {metrics.daily_limit_pct}%. "
                f"Only {metrics.limit_remaining_pct:.2f}% remaining."
            )
        )

async def _create_alert(self, severity: str, title: str, message: str) -> None:
    """Create alert via alert service."""
    from walltrack.services.alerts.alert_service import get_alert_service

    alert_service = await get_alert_service()
    await alert_service.create_alert(
        alert_type="daily_limit",
        severity=severity,
        title=title,
        message=message,
        data={
            "date": datetime.now(timezone.utc).date().isoformat(),
        },
        dedupe_key=f"daily_limit_{severity}_{datetime.now(timezone.utc).date()}"
    )
```

## Implementation Tasks

- [ ] Create DailyLossTracker class
- [ ] Implement realized/unrealized P&L calculation
- [ ] Create daily_snapshots migration
- [ ] Create daily snapshot job
- [ ] Integrate with RiskManager.check_entry_allowed
- [ ] Add warning alerts at 80% threshold
- [ ] Create Gradio daily_pnl panel
- [ ] Add auto-refresh for daily P&L display
- [ ] Write unit tests
- [ ] Write integration tests

## Definition of Done

- [ ] Daily P&L calculated correctly (realized + unrealized)
- [ ] Entries blocked when limit hit
- [ ] Exits still allowed when blocked
- [ ] Midnight UTC resets the counter
- [ ] Warning at 80% of limit
- [ ] Alert created when limit hit
- [ ] Gradio shows clear status
- [ ] Full test coverage

## File List

### New Files
- `src/walltrack/services/risk/daily_loss_tracker.py` - Daily loss tracking
- `src/walltrack/services/jobs/daily_snapshot.py` - Snapshot job
- `src/walltrack/ui/components/daily_pnl.py` - Daily P&L panel
- `migrations/V11__daily_snapshots.sql` - Snapshots table
- `tests/unit/services/risk/test_daily_loss.py` - Tests

### Modified Files
- `src/walltrack/services/risk/risk_manager.py` - Add daily limit check
- `src/walltrack/ui/pages/dashboard.py` - Add daily P&L panel
