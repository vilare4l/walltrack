# Story 10.5.9: Drawdown-Based Size Reduction

## Story Info
- **Epic**: Epic 10.5 - Order Management, Price Oracle & Risk-Based Sizing
- **Status**: ready
- **Priority**: P1 - High
- **Story Points**: 3
- **Depends on**: Story 10.5.8 (Risk-Based Sizing)

## User Story

**As a** risk-conscious trader,
**I want** réduire automatiquement la taille des positions quand le drawdown augmente,
**So that** le système protège le capital en période difficile.

## Acceptance Criteria

### AC 1: Tiered Size Reduction
**Given** le drawdown actuel est de 12%
**When** je calcule la taille d'une nouvelle position
**Then** je consulte drawdown_reduction_tiers
**And** tier 10% (size_reduction_pct=25) s'applique
**And** la taille est réduite de 25%

### AC 2: Progressive Reduction
**Given** les tiers configurés sont [5%→0%, 10%→25%, 15%→50%, 20%→100%]
**When** drawdown = 18%
**Then** le tier 15% s'applique (le plus proche en dessous)
**And** la taille est réduite de 50%

### AC 3: Full Stop at Max Tier
**Given** drawdown >= 20% (tier max avec reduction=100%)
**When** un signal arrive
**Then** aucune position n'est ouverte
**And** un message explicite est loggé

### AC 4: Recovery Behavior
**Given** le drawdown était à 15% (reduction 50%)
**When** le drawdown descend à 8%
**Then** la réduction passe à 0%
**And** les tailles reviennent à la normale

### AC 5: Gradio Display
**Given** je suis sur le dashboard
**When** je regarde le panel Risk Status
**Then** je vois le drawdown actuel
**And** le tier actif (ou "Normal" si aucun)
**And** la réduction appliquée en %

## Technical Specifications

### Drawdown Calculator

**src/walltrack/services/risk/drawdown_calculator.py:**
```python
"""Calculates portfolio drawdown metrics."""

from dataclasses import dataclass
from datetime import datetime, timedelta
from decimal import Decimal
from typing import Optional

import structlog

logger = structlog.get_logger(__name__)


@dataclass
class DrawdownMetrics:
    """Current drawdown metrics."""
    peak_capital: Decimal
    current_capital: Decimal
    drawdown_pct: Decimal
    peak_date: datetime
    days_since_peak: int

    @property
    def is_at_peak(self) -> bool:
        """Check if currently at peak."""
        return self.drawdown_pct <= Decimal("0.01")


class DrawdownCalculator:
    """
    Calculates portfolio drawdown from peak.

    Uses rolling window to track high-water mark.
    """

    def __init__(
        self,
        lookback_days: int = 30,
    ):
        self.lookback_days = lookback_days

    async def calculate(self) -> DrawdownMetrics:
        """Calculate current drawdown metrics."""
        from walltrack.data.supabase.client import get_supabase_client

        client = await get_supabase_client()

        # Get current portfolio value
        current = await self._get_current_capital(client)

        # Get peak value in lookback period
        peak, peak_date = await self._get_peak_capital(client)

        if peak == Decimal("0"):
            # No history, use current as peak
            peak = current
            peak_date = datetime.utcnow()

        # Calculate drawdown
        if peak > 0:
            drawdown_pct = ((peak - current) / peak) * 100
        else:
            drawdown_pct = Decimal("0")

        days_since_peak = (datetime.utcnow() - peak_date).days

        metrics = DrawdownMetrics(
            peak_capital=peak,
            current_capital=current,
            drawdown_pct=max(Decimal("0"), drawdown_pct),
            peak_date=peak_date,
            days_since_peak=days_since_peak,
        )

        logger.debug(
            "drawdown_calculated",
            current=str(current),
            peak=str(peak),
            drawdown_pct=str(drawdown_pct)
        )

        return metrics

    async def _get_current_capital(self, client) -> Decimal:
        """Get current portfolio capital."""
        # Sum of wallet balance + open positions value
        result = await client.table("portfolio_snapshots") \
            .select("total_value_sol") \
            .order("timestamp", desc=True) \
            .limit(1) \
            .execute()

        if result.data:
            return Decimal(str(result.data[0]["total_value_sol"]))

        # Fallback: calculate from positions
        return await self._calculate_portfolio_value(client)

    async def _get_peak_capital(self, client) -> tuple[Decimal, datetime]:
        """Get peak capital in lookback period."""
        cutoff = datetime.utcnow() - timedelta(days=self.lookback_days)

        result = await client.table("portfolio_snapshots") \
            .select("total_value_sol, timestamp") \
            .gte("timestamp", cutoff.isoformat()) \
            .order("total_value_sol", desc=True) \
            .limit(1) \
            .execute()

        if result.data:
            return (
                Decimal(str(result.data[0]["total_value_sol"])),
                datetime.fromisoformat(result.data[0]["timestamp"].replace("Z", "+00:00"))
            )

        return Decimal("0"), datetime.utcnow()

    async def _calculate_portfolio_value(self, client) -> Decimal:
        """Calculate portfolio value from open positions."""
        result = await client.table("positions") \
            .select("entry_amount_sol, unrealized_pnl") \
            .eq("status", "open") \
            .execute()

        total = Decimal("0")
        for row in result.data:
            entry = Decimal(str(row["entry_amount_sol"]))
            pnl = Decimal(str(row.get("unrealized_pnl", 0) or 0))
            total += entry + pnl

        return total


# Singleton
_calculator: Optional[DrawdownCalculator] = None


async def get_drawdown_calculator() -> DrawdownCalculator:
    """Get or create drawdown calculator."""
    global _calculator
    if _calculator is None:
        _calculator = DrawdownCalculator()
    return _calculator
```

### Size Reduction Applicator

**src/walltrack/services/risk/size_reduction.py:**
```python
"""Applies drawdown-based size reduction."""

from dataclasses import dataclass
from decimal import Decimal
from typing import Optional

import structlog

from walltrack.services.risk.drawdown_calculator import (
    DrawdownCalculator,
    DrawdownMetrics,
    get_drawdown_calculator
)
from walltrack.services.config.config_service import ConfigService, get_config_service

logger = structlog.get_logger(__name__)


@dataclass
class ReductionTier:
    """A single reduction tier."""
    threshold_pct: Decimal
    size_reduction_pct: Decimal


@dataclass
class SizeReductionResult:
    """Result of size reduction calculation."""
    original_size: Decimal
    reduced_size: Decimal
    reduction_pct: Decimal
    active_tier: Optional[ReductionTier]
    drawdown_metrics: DrawdownMetrics
    trading_blocked: bool

    @property
    def is_reduced(self) -> bool:
        """Check if size was reduced."""
        return self.reduction_pct > Decimal("0")


class SizeReductionApplicator:
    """
    Applies drawdown-based size reduction.

    Reduces position sizes progressively as drawdown increases.
    """

    def __init__(
        self,
        drawdown_calc: DrawdownCalculator,
        config_service: ConfigService,
    ):
        self.drawdown_calc = drawdown_calc
        self.config_service = config_service

    async def apply_reduction(
        self,
        base_size_sol: Decimal,
    ) -> SizeReductionResult:
        """
        Apply drawdown-based reduction to position size.

        Args:
            base_size_sol: Original position size in SOL

        Returns:
            SizeReductionResult with reduced size and details
        """
        # Get current drawdown
        metrics = await self.drawdown_calc.calculate()

        # Get reduction tiers from config
        config = await self.config_service.get_trading_config()
        tiers = self._parse_tiers(config.drawdown_reduction_tiers)

        # Find applicable tier
        active_tier = self._find_active_tier(metrics.drawdown_pct, tiers)

        if active_tier is None:
            # No reduction applies
            return SizeReductionResult(
                original_size=base_size_sol,
                reduced_size=base_size_sol,
                reduction_pct=Decimal("0"),
                active_tier=None,
                drawdown_metrics=metrics,
                trading_blocked=False,
            )

        # Check if trading should be blocked (100% reduction)
        if active_tier.size_reduction_pct >= Decimal("100"):
            logger.warning(
                "trading_blocked_by_drawdown",
                drawdown_pct=str(metrics.drawdown_pct),
                threshold=str(active_tier.threshold_pct)
            )
            return SizeReductionResult(
                original_size=base_size_sol,
                reduced_size=Decimal("0"),
                reduction_pct=Decimal("100"),
                active_tier=active_tier,
                drawdown_metrics=metrics,
                trading_blocked=True,
            )

        # Apply reduction
        reduction_multiplier = (Decimal("100") - active_tier.size_reduction_pct) / Decimal("100")
        reduced_size = base_size_sol * reduction_multiplier

        logger.info(
            "size_reduction_applied",
            original=str(base_size_sol),
            reduced=str(reduced_size),
            reduction_pct=str(active_tier.size_reduction_pct),
            drawdown=str(metrics.drawdown_pct)
        )

        return SizeReductionResult(
            original_size=base_size_sol,
            reduced_size=reduced_size,
            reduction_pct=active_tier.size_reduction_pct,
            active_tier=active_tier,
            drawdown_metrics=metrics,
            trading_blocked=False,
        )

    def _parse_tiers(self, tiers_json: list[dict]) -> list[ReductionTier]:
        """Parse tier configuration."""
        tiers = []
        for tier_data in tiers_json:
            tiers.append(ReductionTier(
                threshold_pct=Decimal(str(tier_data["threshold_pct"])),
                size_reduction_pct=Decimal(str(tier_data["size_reduction_pct"])),
            ))
        # Sort by threshold ascending
        return sorted(tiers, key=lambda t: t.threshold_pct)

    def _find_active_tier(
        self,
        drawdown_pct: Decimal,
        tiers: list[ReductionTier]
    ) -> Optional[ReductionTier]:
        """Find the highest tier that applies."""
        active = None
        for tier in tiers:
            if drawdown_pct >= tier.threshold_pct:
                active = tier
            else:
                break
        return active


# Singleton
_applicator: Optional[SizeReductionApplicator] = None


async def get_size_reduction_applicator() -> SizeReductionApplicator:
    """Get or create size reduction applicator."""
    global _applicator
    if _applicator is None:
        _applicator = SizeReductionApplicator(
            drawdown_calc=await get_drawdown_calculator(),
            config_service=await get_config_service(),
        )
    return _applicator
```

### Integration with PositionSizer

**src/walltrack/services/risk/position_sizer.py (modification):**
```python
# Dans la méthode calculate_size, après le calcul de base:

async def calculate_size(
    self,
    signal: Signal,
    current_price: Decimal,
) -> PositionSizeResult:
    """Calculate position size with drawdown reduction."""

    # Step 1: Calculate base size
    base_result = await self._calculate_base_size(signal, current_price)

    # Step 2: Apply drawdown-based reduction
    from walltrack.services.risk.size_reduction import get_size_reduction_applicator

    reduction_applicator = await get_size_reduction_applicator()
    reduction_result = await reduction_applicator.apply_reduction(
        base_size_sol=base_result.amount_sol
    )

    # Step 3: Check if blocked
    if reduction_result.trading_blocked:
        return PositionSizeResult(
            amount_sol=Decimal("0"),
            mode=base_result.mode,
            blocked=True,
            block_reason="Drawdown limit reached - trading paused",
            drawdown_reduction_pct=Decimal("100"),
        )

    # Step 4: Return adjusted size
    return PositionSizeResult(
        amount_sol=reduction_result.reduced_size,
        mode=base_result.mode,
        blocked=False,
        drawdown_reduction_pct=reduction_result.reduction_pct,
        original_size=base_result.amount_sol,
    )
```

### Gradio Risk Status Component

**src/walltrack/ui/components/risk_status.py:**
```python
"""Risk status display with drawdown indicator."""

import gradio as gr
from decimal import Decimal


def create_risk_status_panel():
    """Create risk status panel for dashboard."""

    with gr.Column() as risk_panel:
        gr.Markdown("### Risk Status")

        with gr.Row():
            current_drawdown = gr.Number(
                label="Current Drawdown %",
                precision=2,
                interactive=False
            )
            days_since_peak = gr.Number(
                label="Days Since Peak",
                precision=0,
                interactive=False
            )

        with gr.Row():
            active_tier = gr.Textbox(
                label="Active Tier",
                interactive=False
            )
            size_reduction = gr.Textbox(
                label="Size Reduction",
                interactive=False
            )

        with gr.Row():
            trading_status = gr.Textbox(
                label="Trading Status",
                interactive=False
            )

        # Visual indicator
        drawdown_bar = gr.Slider(
            minimum=0,
            maximum=30,
            value=0,
            label="Drawdown Level",
            interactive=False
        )

    return risk_panel, {
        "current_drawdown": current_drawdown,
        "days_since_peak": days_since_peak,
        "active_tier": active_tier,
        "size_reduction": size_reduction,
        "trading_status": trading_status,
        "drawdown_bar": drawdown_bar,
    }


async def update_risk_status():
    """Update risk status display."""
    from walltrack.services.risk.size_reduction import get_size_reduction_applicator

    applicator = await get_size_reduction_applicator()

    # Get reduction for a hypothetical 1 SOL position
    result = await applicator.apply_reduction(Decimal("1"))

    metrics = result.drawdown_metrics

    if result.trading_blocked:
        trading_status = "BLOCKED - Drawdown limit reached"
        tier_text = f"Max tier ({result.active_tier.threshold_pct}%)"
        reduction_text = "100% (Trading paused)"
    elif result.active_tier:
        trading_status = "REDUCED - Size adjustment active"
        tier_text = f"Tier {result.active_tier.threshold_pct}%"
        reduction_text = f"-{result.active_tier.size_reduction_pct}%"
    else:
        trading_status = "NORMAL - Full position sizes"
        tier_text = "None"
        reduction_text = "0%"

    return (
        float(metrics.drawdown_pct),
        metrics.days_since_peak,
        tier_text,
        reduction_text,
        trading_status,
        float(metrics.drawdown_pct),
    )
```

## Implementation Tasks

- [ ] Create DrawdownCalculator class
- [ ] Add portfolio_snapshots query
- [ ] Create SizeReductionApplicator
- [ ] Parse drawdown_reduction_tiers from config
- [ ] Find and apply active tier
- [ ] Integrate with PositionSizer
- [ ] Handle 100% reduction (trading blocked)
- [ ] Create Gradio risk_status panel
- [ ] Add auto-refresh for risk status
- [ ] Write unit tests

## Definition of Done

- [ ] Drawdown calculated from portfolio snapshots
- [ ] Correct tier selected based on drawdown %
- [ ] Size reduced progressively with tiers
- [ ] Trading blocked at 100% reduction tier
- [ ] Recovery restores normal sizing
- [ ] Gradio shows current risk status
- [ ] Full test coverage

## File List

### New Files
- `src/walltrack/services/risk/drawdown_calculator.py` - Drawdown calculation
- `src/walltrack/services/risk/size_reduction.py` - Size reduction logic
- `src/walltrack/ui/components/risk_status.py` - Risk status panel
- `tests/unit/services/risk/test_drawdown.py` - Drawdown tests
- `tests/unit/services/risk/test_size_reduction.py` - Reduction tests

### Modified Files
- `src/walltrack/services/risk/position_sizer.py` - Integrate size reduction
- `src/walltrack/ui/pages/dashboard.py` - Add risk status panel
